/*
 * GENERATED WITH FAIMS-TOOLS, SHA1: 395e6197e31d52a07d17153bb2ece8e0435d7ed6
 */
import android.util.Log;
import android.os.Build.MODEL;
import java.util.concurrent.atomic.AtomicInteger;

// Beanshell won't let me write "\0".
final String SEP = Character.toString ((char) 0);

final String MSG_LOADING = "Loading...";

final String USER_MENU_PATH = "Login/User_login/Users";
userMenuPath = USER_MENU_PATH; // Depricated. Use `USER_MENU_PATH` instead

final long SESS_START_TIME = System.currentTimeMillis();

Object dialog;          // Used to help coordinate the display of a "busy..." dialog
String parentTabgroup;  // Used to allow entities to be saved as children
String parentTabgroup__;// The tab group which was previously displayed
String redirectTab;     // makes newTab work as expected
String username = "";
String userId   = "";
List   autoSaveGeo = null;
List   autoSaveAttrs = null;

setFileSyncEnabled(true);
setSyncDelay(5.0f);
setSyncEnabled(true);
setSyncMaxInterval(600.0f);
setSyncMinInterval(5.0f);

if (isNull(USER_MENU_PATH)) {
  Log.w("", "`USER_MENU_PATH` is empty or null");
}

boolean isInUnitTestTime() {
  return android.os.Build.MODEL.equals("faims-mock-device");
}

void assert(boolean condition) {
  if (condition)
    return;

  String msg =
    "Test failed: " +
    "Line: " + this.namespace.getInvocationLine() +
    ": "     + this.namespace.getInvocationText() +
    ". "     + this.callstack;

  throw new Exception(msg);
}

// Like `any` in Python
boolean any(List booleans) {
  for (b : booleans)
    if (b) return true;
  return false;
}

String listToSqlString(List l){
  String sqlString = "(";
  for (int i = 0; i < l.size() - 1; i++) {
    element = l.get(i);
    sqlString += "'" + element + "', ";
  }
  if (l.size() > 0) {
    int lastIndex = l.size() - 1;
    element = l.get(lastIndex);
    sqlString += "'" + element + "'";
  }
  sqlString += ")";

  return sqlString;
}

// Run a list of queries one-after-the-other. The next query starts executing
// once the previous finishes.
//
// `callbacks` is a list of `FetchCallback` objects corresponding to each query
// in `queries`. Although `callbacks` cannot be null, any of it elements can.
void sequentialFetchAll(List queries, List callbacks) {
  if (queries == null || callbacks == null)
    throw IllegalArgumentException("Arguments cannot be null");
  if (queries.size() != callbacks.size())
    throw IllegalArgumentException("Argument lists must have the same length");

  if (queries.size() == 0)
    return;

  String        queriesHead   = queries  .get(0);
  FetchCallback callbacksHead = callbacks.get(0);

  List queriesTail   = queries  .subList(1, queries  .size());
  List callbacksTail = callbacks.subList(1, callbacks.size());

  FetchCallback executeTail = new FetchCallback() {
    onFetch(result) {
      if (callbacksHead != null)
        callbacksHead.onFetch(result);

      sequentialFetchAll(queriesTail, callbacksTail);
    }

    onError(String message) {
      if (callbacksHead != null)
        callbacksHead.onError(message);
    }
  };

  fetchAll(queriesHead, executeTail);
}

/******************************************************************************/
/*                                STRING UTILS                                */
/******************************************************************************/

/* Works similarly to Java's String.replaceFirst, except the `needle` is a
 * string instead of a regex.
 */
String replaceFirst(String haystack, String needle, String replacement) {
  i = haystack.indexOf(needle);
  if (i == -1)           return haystack;
  if (needle.equals("")) return haystack;
  pre  = haystack.substring(0, i                                   );
  post = haystack.substring(   i+needle.length(), haystack.length());
  return pre + replacement + post;
}

String replaceFirst(String haystack, String replacement) {
  return replaceFirst(haystack, "%s", replacement);
}

/* Replaces `placeholder` in an SQL `query` with `replacement`. The following
 * example returns the string
 * "SELECT * FROM table WHERE col1 = 'my replacement'":
 *
 * dbReplaceFirst(
 *     "SELECT * FROM table WHERE col1 = {my_placeholder}",
 *     "{my_placeholder}",
 *     "my replacement"
 * );
 */
String dbReplaceFirst(String query, String placeholder, String replacement) {
  String escapedReplacement = DatabaseUtils.sqlEscapeString(replacement);
  return replaceFirst(query, placeholder, escapedReplacement);
}

String dbReplaceFirst(String query, String replacement) {
  return dbReplaceFirst(query, "%s", replacement);
}

String translate(String s, Map m) {
  String out = "";

  for (char c : s) {
    String translation = m.get(c);

    if (isNull(translation)) out += c;
    else                     out += translation;
  }

  return out;
}

String escape(String s) {
  Map dict = new HashMap();
  dict.put('\"', "\\\"");
  dict.put('\\', "\\\\");
  dict.put('\b', "\\b" );
  dict.put('\f', "\\f" );
  dict.put('\n', "\\n" );
  dict.put('\r', "\\r" );

  return translate(s, dict);
}

Map MEMOISED_FILTERED_BY_REGEX = new LinkedHashMap();

List filterListByRegex(List unfiltered, String regex, boolean forceUpdate) {
  // Return a copy of the memoised result if possible. It's important to return
  // a copy because if the contents of the list are modified, memoisation will
  // break.
  List key = new ArrayList();
  key.add(unfiltered);
  key.add(regex);

  List memoised = MEMOISED_FILTERED_BY_REGEX.get(key);
  if (memoised != null && !forceUpdate)
    return new ArrayList(memoised);

  // Compute the filtered list
  List filteredList;
  Set  filteredSet = new LinkedHashSet();
  for (element : unfiltered)
    if (element.matches(regex))
      filteredSet.add(element);
  filteredList = new ArrayList(filteredSet);

  // Memoise and return
  MEMOISED_FILTERED_BY_REGEX.put(key, filteredList);
  return new ArrayList(filteredList);
}

List filterListByRegex(List unfiltered, String regex) {
  return filterListByRegex(unfiltered, regex, false);
}

String getRandomString(int len) {
  char[] chars  = (
      "abcdefghijklmnopqrstuvwxyz" +
      "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
      "1234567890"
  ).toCharArray();
  Random random = new Random();

  StringBuilder sb = new StringBuilder();
  for (int i = 0; i < len; i++) {
      char c = chars[random.nextInt(chars.length)];
      sb.append(c);
  }

  return sb.toString();
}

String args2str(Object[] args) {
  String str = "";
  String sep = ", ";

  for (Object o : args) {
    if (o instanceof String) str += "\"" + escape(o) + "\"" + sep;
    else                     str +=               o         + sep;
  }

  // The loop adds a superfluous trailing separator. This removes it.
  str = str.substring(0, str.length() - sep.length());

  return str;
}

// "Function to string". Makes it very slightly less painful to write callback
// functions as strings.
String fun2str(String funName, Object[] args) {
  String argsStr = args2str(args);

  String str = "{funName}({argsStr})";
  str = replaceFirst(str, "{funName}", funName);
  str = replaceFirst(str, "{argsStr}", argsStr);

  return str;
}

String fun2str(String funName, Object args) {
  return fun2str(funName, new Object[]{args});
}

/************************** FUNCTION-STRING MAPPING ***************************/
/* Allows reflected functions to be associated with a key and called later    */
/* on. This is mostly useful for de-spagehettifying calls to `addOnEvent`,    */
/* which would otherwise effectively use eval.                                */
/******************************************************************************/
Map KEY_TO_FUN_NAME = new HashMap();
Map KEY_TO_FUN_ARGS = new HashMap();

String function2key(String function, Object[] args) {
  if (args == null)
    args = new Object[0];

  String key = getRandomString(64); // 64 ==> Odds of collision ~= 1e-115

  KEY_TO_FUN_NAME.put(key, function);
  KEY_TO_FUN_ARGS.put(key, args);

  return key;
}

key2call(String key) {
  String   funName = KEY_TO_FUN_NAME.get(key);
  Object[] funArgs = KEY_TO_FUN_ARGS.get(key);

  if (funName == null) return;
  if (funArgs == null) return;

  this.invokeMethod(funName, funArgs);
}

String function2callableString(String function, Object[] args) {
  return fun2str("key2call", function2key(function, args));
}

/******************************************************************************/
/*                           DOCUMENT OBJECT MODEL                            */
/******************************************************************************/
String  PREVIOUSLY_DISPLAYED_TAB_GROUP = "";
String  CURRENTLY_DISPLAYED_TAB_GROUP  = "";
String  PREVIOUSLY_DISPLAYED_TAB       = "";
String  CURRENTLY_DISPLAYED_TAB        = "";
Map     REF_TO_TYPE                    = new LinkedHashMap();
HashSet DATA_REFS                      = new HashSet();
HashSet NO_UI_REFS                     = new HashSet();
HashSet HIER_REFS                      = new HashSet();
Map     VP_REF_TO_REF                  = new HashMap();
HashSet REFS_AS_HASH_SET               = null;
List    REFS_AS_LIST                   = null;
List    TAB_GROUPS_AS_LIST             = new ArrayList();
HashSet TAB_GROUPS_AS_HASH_SET         = null;
List    TABS_AS_LIST                   = new ArrayList();
HashSet TABS_AS_HASH_SET               = null;
HashMap ATTRIB_NAMES_NON_STANDARD      = new HashMap();
List    NODATA_TAB_GROUPS              = new ArrayList();
NODATA_TAB_GROUPS.add("Login");
  NODATA_TAB_GROUPS.add("General");

REF_TO_TYPE.put("Login/User_login/Guide_User_Login", "webview");
REF_TO_TYPE.put("Login/User_login/Users", "dropdown");
REF_TO_TYPE.put("Login/User_login/Log_in", "button");
REF_TO_TYPE.put("Login/User_login/Signup_Guide_1", "webview");
REF_TO_TYPE.put("Login/User_login/Sign_up", "button");
REF_TO_TYPE.put("Login/Manual/Manual", "webview");
REF_TO_TYPE.put("Login/Manual/Go_to_Login_Tab", "button");
REF_TO_TYPE.put("General/General/Start_Trip", "button");
REF_TO_TYPE.put("General/Search/Search_Term", "input");
REF_TO_TYPE.put("General/Search/Search_Button", "button");
REF_TO_TYPE.put("General/Search/Entity_Types", "dropdown");
REF_TO_TYPE.put("General/Search/Entity_List", "list");
REF_TO_TYPE.put("General/Manual/Manual", "webview");
REF_TO_TYPE.put("General/Manual/Start_Recording", "button");
REF_TO_TYPE.put("Trip/Trip_data/Trip_author", "input");
REF_TO_TYPE.put("Trip/Trip_data/Date", "input");
REF_TO_TYPE.put("Trip/Trip_data/Time", "input");
REF_TO_TYPE.put("Trip/Trip_data/Subregion", "dropdown");
REF_TO_TYPE.put("Trip/Trip_data/GPS_Guide", "webview");
REF_TO_TYPE.put("Trip/Trip_data/Latitude", "input");
REF_TO_TYPE.put("Trip/Trip_data/Longitude", "input");
REF_TO_TYPE.put("Trip/Trip_data/Northing", "input");
REF_TO_TYPE.put("Trip/Trip_data/Easting", "input");
REF_TO_TYPE.put("Trip/Trip_data/Accuracy", "input");
REF_TO_TYPE.put("Trip/Trip_data/Take_From_GPS_1", "button");
REF_TO_TYPE.put("Trip/Shoreline_attributes/Natural_habitat_types", "checkbox");
REF_TO_TYPE.put("Trip/Shoreline_attributes/Artificial_habitat_types", "checkbox");
REF_TO_TYPE.put("Trip/Shoreline_attributes/Dominant_habitat", "input");
REF_TO_TYPE.put("Trip/Shoreline_attributes/Adjacent_land_use", "checkbox");
REF_TO_TYPE.put("Trip/Shoreline_attributes/Wastewater_outflows", "radio");
REF_TO_TYPE.put("Trip/Shoreline_attributes/Habitat_photo", "camera");
REF_TO_TYPE.put("Trip/Shoreline_attributes/Habitat_photo_Button_1", "button");
REF_TO_TYPE.put("Trip/Shoreline_attributes/Animals_present", "checkbox");
REF_TO_TYPE.put("Trip/Shoreline_attributes/Shoreline_slope", "dropdown");
REF_TO_TYPE.put("Trip/Shoreline_attributes/Check_for_Missing_Data", "button");
REF_TO_TYPE.put("Trip/Shellfish_Aggregation/Add_Shellfish_Aggregation_Guide", "webview");
REF_TO_TYPE.put("Trip/Shellfish_Aggregation/Add_Shellfish_Aggregation", "button");
REF_TO_TYPE.put("Trip/Shellfish_Aggregation/HR_Guide", "webview");
REF_TO_TYPE.put("Trip/Shellfish_Aggregation/Existing_Aggregations_Guide", "webview");
REF_TO_TYPE.put("Trip/Shellfish_Aggregation/Existing_Aggregations", "list");
REF_TO_TYPE.put("Shellfish_Aggregation/Shellfish_Type/Date", "input");
REF_TO_TYPE.put("Shellfish_Aggregation/Shellfish_Type/Time", "input");
REF_TO_TYPE.put("Shellfish_Aggregation/Shellfish_Type/Subregion", "input");
REF_TO_TYPE.put("Shellfish_Aggregation/Shellfish_Type/Shellfish_type", "dropdown");
REF_TO_TYPE.put("Shellfish_Aggregation/Shellfish_Type/Shellfish_species", "picture");
REF_TO_TYPE.put("Shellfish_Aggregation/Shellfish_Type/Shellfish_Photo", "camera");
REF_TO_TYPE.put("Shellfish_Aggregation/Shellfish_Type/Shellfish_Photo_Button_1", "button");
REF_TO_TYPE.put("Shellfish_Aggregation/Shellfish_Type/Primary_substrate", "dropdown");
REF_TO_TYPE.put("Shellfish_Aggregation/Shellfish_Type/Surrounding_substrate", "dropdown");
REF_TO_TYPE.put("Shellfish_Aggregation/Shellfish_Type/Shellfish_status", "radio");
REF_TO_TYPE.put("Shellfish_Aggregation/Aggregation_Attributes/Distance_to_water_in_m", "radio");
REF_TO_TYPE.put("Shellfish_Aggregation/Aggregation_Attributes/Size_of_aggregation", "picture");
REF_TO_TYPE.put("Shellfish_Aggregation/Aggregation_Attributes/Density_of_aggregation", "dropdown");
REF_TO_TYPE.put("Shellfish_Aggregation/Aggregation_Attributes/Aggregation_Photos", "camera");
REF_TO_TYPE.put("Shellfish_Aggregation/Aggregation_Attributes/Aggregation_Photos_Button_1", "button");
REF_TO_TYPE.put("Login/User_login", "tab");
REF_TO_TYPE.put("Login/Manual", "tab");
REF_TO_TYPE.put("General/General", "tab");
REF_TO_TYPE.put("General/Search", "tab");
REF_TO_TYPE.put("General/Manual", "tab");
REF_TO_TYPE.put("Trip/Trip_data", "tab");
REF_TO_TYPE.put("Trip/Shoreline_attributes", "tab");
REF_TO_TYPE.put("Trip/Shellfish_Aggregation", "tab");
REF_TO_TYPE.put("Shellfish_Aggregation/Shellfish_Type", "tab");
REF_TO_TYPE.put("Shellfish_Aggregation/Aggregation_Attributes", "tab");

DATA_REFS.add("Trip/Trip_data/Trip_author");
DATA_REFS.add("Trip/Trip_data/Date");
DATA_REFS.add("Trip/Trip_data/Time");
DATA_REFS.add("Trip/Trip_data/Subregion");
DATA_REFS.add("Trip/Trip_data/Latitude");
DATA_REFS.add("Trip/Trip_data/Longitude");
DATA_REFS.add("Trip/Trip_data/Northing");
DATA_REFS.add("Trip/Trip_data/Easting");
DATA_REFS.add("Trip/Trip_data/Accuracy");
DATA_REFS.add("Trip/Shoreline_attributes/Natural_habitat_types");
DATA_REFS.add("Trip/Shoreline_attributes/Artificial_habitat_types");
DATA_REFS.add("Trip/Shoreline_attributes/Dominant_habitat");
DATA_REFS.add("Trip/Shoreline_attributes/Adjacent_land_use");
DATA_REFS.add("Trip/Shoreline_attributes/Wastewater_outflows");
DATA_REFS.add("Trip/Shoreline_attributes/Habitat_photo");
DATA_REFS.add("Trip/Shoreline_attributes/Animals_present");
DATA_REFS.add("Trip/Shoreline_attributes/Shoreline_slope");
DATA_REFS.add("Shellfish_Aggregation/Shellfish_Type/Date");
DATA_REFS.add("Shellfish_Aggregation/Shellfish_Type/Time");
DATA_REFS.add("Shellfish_Aggregation/Shellfish_Type/Subregion");
DATA_REFS.add("Shellfish_Aggregation/Shellfish_Type/Shellfish_type");
DATA_REFS.add("Shellfish_Aggregation/Shellfish_Type/Shellfish_species");
DATA_REFS.add("Shellfish_Aggregation/Shellfish_Type/Shellfish_Photo");
DATA_REFS.add("Shellfish_Aggregation/Shellfish_Type/Primary_substrate");
DATA_REFS.add("Shellfish_Aggregation/Shellfish_Type/Surrounding_substrate");
DATA_REFS.add("Shellfish_Aggregation/Shellfish_Type/Shellfish_status");
DATA_REFS.add("Shellfish_Aggregation/Aggregation_Attributes/Distance_to_water_in_m");
DATA_REFS.add("Shellfish_Aggregation/Aggregation_Attributes/Size_of_aggregation");
DATA_REFS.add("Shellfish_Aggregation/Aggregation_Attributes/Density_of_aggregation");
DATA_REFS.add("Shellfish_Aggregation/Aggregation_Attributes/Aggregation_Photos");





HIER_REFS.add("Trip/Trip_data/Subregion");
HIER_REFS.add("Shellfish_Aggregation/Shellfish_Type/Primary_substrate");
HIER_REFS.add("Shellfish_Aggregation/Shellfish_Type/Surrounding_substrate");

TAB_GROUPS_AS_LIST.add("Login");
TAB_GROUPS_AS_LIST.add("General");
TAB_GROUPS_AS_LIST.add("Trip");
TAB_GROUPS_AS_LIST.add("Shellfish_Aggregation");

TABS_AS_LIST.add("Login/User_login");
TABS_AS_LIST.add("Login/Manual");
TABS_AS_LIST.add("General/General");
TABS_AS_LIST.add("General/Search");
TABS_AS_LIST.add("General/Manual");
TABS_AS_LIST.add("Trip/Trip_data");
TABS_AS_LIST.add("Trip/Shoreline_attributes");
TABS_AS_LIST.add("Trip/Shellfish_Aggregation");
TABS_AS_LIST.add("Shellfish_Aggregation/Shellfish_Type");
TABS_AS_LIST.add("Shellfish_Aggregation/Aggregation_Attributes");

ATTRIB_NAMES_NON_STANDARD.put("Trip/Trip_data/Subregion", "Trip Subregion");
ATTRIB_NAMES_NON_STANDARD.put("Shellfish_Aggregation/Shellfish_Type/Subregion", "Shellfish Aggregation Subregion");

String getType(String ref) {
  String type = REF_TO_TYPE.get(ref);
  if (type == null) return "";
  else              return type;
}

List getRefs() {
  return getRefsAsList();
}

List getRefsAsList() {
  if (REFS_AS_LIST == null)
    REFS_AS_LIST = new ArrayList(REF_TO_TYPE.keySet());
  return REFS_AS_LIST;
}

HashSet getRefsAsHashSet() {
  if (REFS_AS_HASH_SET == null)
    REFS_AS_HASH_SET = new HashSet(REF_TO_TYPE.keySet());
  return REFS_AS_HASH_SET;
}

List getRefsByType(String type) {
  List refs = new ArrayList();
  for (String ref : getRefs())
    if (getType(ref).equals(type))
      refs.add(ref);
  return refs;
}

boolean hasData(String ref) {
  return DATA_REFS.contains(ref);
}

boolean hasNoUi(String ref) {
  return NO_UI_REFS.contains(ref);
}

String getVpRef(String ref) {
  return VP_REF_TO_REF.get(ref);
}

boolean hasVpRef(String ref) {
  return getVpRef(ref) != null;
}

boolean isHier(String ref) {
  return HIER_REFS.contains(ref);
}

boolean isValidRef(String ref) {
    return getRefsAsHashSet()     .contains(ref) ||
           getTabsAsHashSet()     .contains(ref) ||
           getTabGroupsAsHashSet().contains(ref);
}

boolean validateRef(ref) {
  if (!isValidRef(ref) && !"module".equals(ref)) {
    Log.w(
        this.callstack.get(1).getInvocationText(),
        "Ref '" + ref + "' may not refer to a UI element"
    );
    return false;
  }
  return true;
}

List getTabGroups() { return getTabGroupsAsList(); }
List getTabGroupsAsList() { return TAB_GROUPS_AS_LIST; }

HashSet getTabGroupsAsHashSet() {
  if (TAB_GROUPS_AS_HASH_SET == null)
    TAB_GROUPS_AS_HASH_SET = new HashSet(TAB_GROUPS_AS_LIST);
  return TAB_GROUPS_AS_HASH_SET;
}

List getTabs() { return getTabsAsList(); }
List getTabsAsList() { return TABS_AS_LIST; }

HashSet getTabsAsHashSet() {
  if (TABS_AS_HASH_SET == null)
    TABS_AS_HASH_SET = new HashSet(TABS_AS_LIST);
  return TABS_AS_HASH_SET;
}

List getStartingIdRefs() {
  List l = new ArrayList();
  
  return l;
}

List getMenuTypes() {
  List menuTypes = new ArrayList();
  menuTypes.add("checkbox");
  menuTypes.add("dropdown");
  menuTypes.add("list");
  menuTypes.add("picture");
  menuTypes.add("radio");
  return menuTypes;
}

List getMediaTypes() {
  List mediaTypes = new ArrayList();
  mediaTypes.add("audio");
  mediaTypes.add("camera");
  mediaTypes.add("file");
  mediaTypes.add("video");
  return mediaTypes;
}

boolean isMenuType(String type) {
  return getMenuTypes().contains(type);
}

boolean isMediaType(String type) {
  return getMediaTypes().contains(type);
}

boolean hasMenuType(String ref) {
  String refType = getType(ref);
  return isMenuType(refType);
}

boolean hasMediaType(String ref) {
  String type = getType(ref);
  return isMediaType(type);
}

boolean isFlaggedNodata(String tabGroup) {
  return NODATA_TAB_GROUPS.contains(tabGroup);
}

void updateDisplayedTab(String tab) {
  if (tab.equals(CURRENTLY_DISPLAYED_TAB))
    return;

  PREVIOUSLY_DISPLAYED_TAB = CURRENTLY_DISPLAYED_TAB;
  CURRENTLY_DISPLAYED_TAB  = tab;
}

String getPreviouslyDisplayedTab() {
  return PREVIOUSLY_DISPLAYED_TAB;
}

String getDisplayedTab() {
  return CURRENTLY_DISPLAYED_TAB;
}

void updateDisplayedTabGroup(String tabGroup) {
  if (tabGroup.equals(CURRENTLY_DISPLAYED_TAB_GROUP))
    return;

  PREVIOUSLY_DISPLAYED_TAB_GROUP = CURRENTLY_DISPLAYED_TAB_GROUP;
  CURRENTLY_DISPLAYED_TAB_GROUP  = tabGroup;
}

String getPreviousTabGroup() {
  return getPreviouslyDisplayedTabGroup();
}

String getPreviouslyDisplayedTabGroup() {
  return PREVIOUSLY_DISPLAYED_TAB_GROUP;
}

String getDisplayedTabGroup() {
  return CURRENTLY_DISPLAYED_TAB_GROUP;
}

boolean isDisplayed(String ref) {
  return getDisplayedTabGroup().equals(ref) ||
         getDisplayedTab     ().equals(ref);
}

String getTabGroupRef(String fullRef) {
  Boolean lastPartOnly = false;
  return getTabGroupRef(fullRef, lastPartOnly);
}

String getTabGroupRef(String fullRef, Boolean lastPartOnly) {
  if (isNull(fullRef)) {
    return null;
  }

  String[] parts = fullRef.split("/");

  if (parts.length < 1) return null;
  return parts[0];
}

String getTabRef(String fullRef) {
  Boolean lastPartOnly = false;
  return getTabRef(fullRef, lastPartOnly);
}

String getTabRef(String fullRef, Boolean lastPartOnly) {
  if (isNull(fullRef)) {
    return null;
  }

  String[] parts = fullRef.split("/");

  if (parts.length < 2) return null;
  if (lastPartOnly) return                  parts[1];
  else              return parts[0] + "/" + parts[1];
}

String getLastRefPart(String fullRef) {
  if (isNull(fullRef)) {
    return null;
  }

  String[] parts = fullRef.split("/");
  return parts[parts.length-1];
}

String getGuiElementRef(String fullRef) {
  Boolean lastPartOnly = true;
  return getGuiElementRef(fullRef, lastPartOnly);
}

String getGuiElementRef(String fullRef, Boolean lastPartOnly) {
  if (isNull(fullRef)) {
    return null;
  }

  String[] parts = fullRef.split("/");

  if (parts.length < 3) return null;
  if (lastPartOnly) return parts[2];
  else              return fullRef;
}

boolean isTab(String ref) {
  return getTabsAsHashSet().contains(ref);
}

boolean isTabGroup(String ref) {
  return getTabGroupsAsHashSet().contains(ref);
}

String getArch16nKey(String ref) {
  String lastRefPart = getLastRefPart(ref);

  if (isNull(lastRefPart)) return null;
  else                     return "{" + lastRefPart + "}";
}

String guessArch16nVal(String ref) {
  return guessArch16nValFromRef(ref);
}

String guessArch16nValFromRef(String ref) {
  String arch16nKey = getArch16nKey(ref);
  return guessArch16nValFromKey(arch16nKey);
}

String guessArch16nValFromKey(String key) {
  if (isNull(key)) return "";
  key = key.replaceAll("_", " ");
  key = key.replaceAll("^\\{", "");
  key = key.replaceAll("\\}$", "");
  return key;
}

String getAttributeName(String ref) {
  String guiElementRef = getGuiElementRef(ref);
  if (isNull(guiElementRef))
    return null;

  if (ATTRIB_NAMES_NON_STANDARD.containsKey(ref))
    return ATTRIB_NAMES_NON_STANDARD.get(ref);

  return guiElementRef.replaceAll("_", " ");
}

List getAttribsMatchingRef(String pattern) {
  Set attribsSet;

  List attribsList = new ArrayList();
  for (ref : getRefsMatching(pattern))
    attribsList.add(getAttributeName(ref));

  attribsSet  = new HashSet(attribsList);
  attribsList = new ArrayList(attribsSet);

  return attribsList;
}

String getArchEntType(String ref) {
  String tabGroupRef = getTabGroupRef(ref);
  if (isNull(tabGroupRef)) {
    return null;
  }

  String archEntType = tabGroupRef.replaceAll("_", " ");
  return archEntType;
}

String getArchEntTypePascalCased(String ref) {
  String archEntType = getArchEntType(ref);
  if (archEntType == null) {
    return archEntType;
  }

  return archEntType.replaceAll(" ", "");
}

List getRefsMatching(String pattern) {
  Map dict = new HashMap();
  dict.put('/', "\\/");
  dict.put('*', ".*");
  String regex = translate(pattern, dict);

  return filterListByRegex(getRefs(), regex);
}

String getRefMatching(String pattern) {
  List matches = getRefsMatching(pattern);
  if (matches.size() == 0)
    return "";
  return matches.get(0);
}

/******************************************************************************/
/*                            BINDING ACCUMULATOR                             */
/*                                                                            */
/* The binding accumulator allows onEvent bindings for the same element to    */
/* accumulate over multiple onEvent calls instead of having later calls       */
/* override earlier ones.                                                     */
/*                                                                            */
/* It also adds support for a several additional events:                      */
/*   - "blur" --- This is merely an interface to make code for adding "blur"  */
/*         events more consistent.                                            */
/*   - "copy" --- Triggered as a record is duplicated, immediately before it  */
/*         is first saved.                                                    */
/*   - "create" --- Triggered after a savable, auto-generated tab group is    */
/*         shown (but possibly before the "show" event is triggered).         */
/*   - "delete" --- Triggered after a record is deleted.                      */
/*   - "prefetch" --- Triggered before the "fetch" event. More specifically,  */
/*         this event is triggered before a tab group is fetched and          */
/*         displayed.                                                         */
/*   - "fetch" --- Triggered after a record is fetched and displayed in a     */
/*         given tab group.                                                   */
/*   - "focus" --- This is merely an interface to make code for adding        */
/*         "focus" events more consistent.                                    */
/*   - "leave" --- Triggered after a given tab group is navigated away        */
/*         from. Note that this event cannot be triggered when the FAIMS app  */
/*         is exited.                                                         */
/*   - "save" --- Triggered each time a tab group is saved. This includes the */
/*         first time the tab group is saved as well as subsequent            */
/*         onSave(String, Boolean) calls.                                     */
/*   - "firstsave" --- Similar to "save", but only triggered upon the first   */
/*         save (i.e. the save which creates the arch ent). When this event   */
/*         is triggered, it occurs immediately before the "save" event.       */
/*                                                                            */
/* Additionally, the binding accumulator augments the "load" event so that    */
/* the `statement` in addOnEvent("module", "load", statement) gets executed   */
/* after the module has finished loading. (That is, when this script has been */
/* loaded, including the execution of any asynchronous functions.)            */
/*                                                                            */
/* Importantly, a single call to `bindOnEvents` must occur after all the      */
/* `addOnEvent` and `delOnEvent` calls. Calling `bindOnEvents` is what        */
/* actually establishes the bindings once they have been added to the         */
/* accumulator.                                                               */
/******************************************************************************/
// This counts the number of _a_synchonrous jobs before the module is considered
// to be loaded.
//     Only one synchronous job is counted, and that's loading this script; that
// is why this variable is initialised to 1.
AtomicInteger NUM_JOBS_TILL_LOADED = new AtomicInteger(1);
AtomicInteger NUM_FETCHES_OCCURING = new AtomicInteger(0);

final int PRECEDENCE_MIN = 0;
final int PRECEDENCE_MID = Integer.MAX_VALUE/2;
final int PRECEDENCE_MAX = Integer.MAX_VALUE;

int NUM_EVTS = 0;
Map ON_EVT_CONDS  = new HashMap(); // (ref, event type) -> callback statement
Map ON_EVT_STMTS  = new HashMap(); // (ref, event type) -> callback statement
Set CUSTOM_EVENTS = new HashSet(); // Events not handled by `onEvent`

CUSTOM_EVENTS.add("blur");
CUSTOM_EVENTS.add("copy");
CUSTOM_EVENTS.add("create");
CUSTOM_EVENTS.add("delete");
CUSTOM_EVENTS.add("fetch");
CUSTOM_EVENTS.add("focus");
CUSTOM_EVENTS.add("leave");
CUSTOM_EVENTS.add("prefetch");
CUSTOM_EVENTS.add("save");
CUSTOM_EVENTS.add("firstsave");

List getPrioritised(String statement, int priority) {
  List prioritised = new ArrayList();

  prioritised.add(statement);
  prioritised.add(priority);
  prioritised.add(NUM_EVTS++);

  return prioritised;
}

Comparator PrioritisedComparator() {
  int compare(List a, List b) {
    int aPriority = a.get(1);
    int bPriority = b.get(1);

    int aEvtNum   = a.get(2);
    int bEvtNum   = b.get(2);

    if (aPriority > bPriority) return -1;
    if (aPriority < bPriority) return +1;
    if (aEvtNum   > bEvtNum  ) return +1;
    if (aEvtNum   < bEvtNum  ) return -1;
    return 0;
  }
  boolean equals(a, b) { return compare(a, b) == 0; }
  return this;
}

String getOnEventKey(String ref, String event) {
  return ref + SEP + event;
}

ArrayList getOnEventPriorities(String ref, String event, Map map) {
  String    key = getOnEventKey(ref, event);
  ArrayList val = (ArrayList) map.get(key);

  if (val == null) return new ArrayList();
  else             return val;
}

/* Returns the set of statements bound to an element at `ref` and occurring on
 * `event`.
 */
ArrayList getOnEventVal(String ref, String event, Map map) {
  String    key  = getOnEventKey(ref, event);
  ArrayList val  = (ArrayList) map.get(key);
  ArrayList val_ = new ArrayList();

  if (val == null)
    val = new ArrayList();

  // Sort the vals by their precedence
  Collections.sort(val, PrioritisedComparator());

  // Unpack the inner objects (Strings) from the `Prioritised` objects, put them
  // in `val_`.
  for (v : val)
    val_.add(v.get(0));

  return val_;
}

ArrayList getConds(String ref, String event) {
  return getOnEventVal(ref, event, ON_EVT_CONDS);
}

ArrayList getStatements(String ref, String event) {
  return getOnEventVal(ref, event, ON_EVT_STMTS);
}

void addToOnEventPriorities(
    String ref,
    String event,
    String statement,
    int precedence,
    Map map
) {
  // In the case that a statement already exists for a given (`ref`, `event`)
  // pair, writing `val.add(statement);` will be enough to add the extra
  // statement. This is because `getStatements` returns a reference to a list.
  // In the case just described, the list is stored in the `ON_EVT_STMTS` map.
  // However, sometimes `getStatements` returns empty lists which are not stored
  // in that map. In this case, calling `ON_EVT_STMTS.put` is required.
  //
  // `precedence` controls the order that statements are executed. Roughly,
  // a statement with a higher precedence is executed before a statement with
  // a lower precedence.
  assert(precedence >= 0);
  assert(precedence <= Integer.MAX_VALUE);

  validateRef(ref);

  String    key = getOnEventKey       (ref, event);
  ArrayList val = getOnEventPriorities(ref, event, map);

  ArrayList statements = val;

  statements.add(getPrioritised(statement, precedence));
  map.put(key, statements);
}

String getOnEventString(
    String ref,
    String event,
    Map map,
    String sep,
    boolean doAddTrailingSep
) {
  ArrayList stmts = getOnEventVal(ref, event, map);
  String stmtsStr = "";

  if (stmts.size() > 0)
    stmtsStr = stmts.get(0);

  for (int i = 1; i < stmts.size(); i++)
    stmtsStr += sep + stmts.get(i);

  if (doAddTrailingSep)
    stmtsStr += sep;

  return stmtsStr;
}

String getStatementsString(String ref, String event) {
  String condsStr = getOnEventString(ref, event, ON_EVT_CONDS, " && ", false);
  String stmtsStr = getOnEventString(ref, event, ON_EVT_STMTS, "; "  , true);

  if (isNull(condsStr))
    return stmtsStr;
  return "if (" + condsStr + ") { " + stmtsStr + " }";
}

void executeOnEvent(String ref, String event) {
  validateRef(ref);

  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}

boolean hasOnEvent(String ref, String event, String statement) {
  return getStatements(ref, event).contains(statement);
}

void delOnEvent(String ref, String event, String statement) {
  validateRef(ref);

  String    key = getOnEventKey(ref, event);
  ArrayList val = (ArrayList) ON_EVT_STMTS.get(key);

  if (val == null)
    return;

  for (Iterator i = val.iterator(); i.hasNext(); ) {
    obj = i.next();
    if (statement.equals(obj.get(0)))
      i.remove();
  }
}

void delOnEvents(String ref, String event) {
  validateRef(ref);

  String key = getOnEventKey(ref, event);
  ON_EVT_STMTS.remove(key);
}

void addOnEvent(String ref, String event, String statement, int precedence) {
  addToOnEventPriorities(ref, event, statement, precedence, ON_EVT_STMTS);
}

void addOnEventCond(String ref, String event, String check) {
  addToOnEventPriorities(ref, event, check, PRECEDENCE_MID, ON_EVT_CONDS);
}

void addOnEvent(String ref, String event, String statement) {
  addOnEvent(ref, event, statement, PRECEDENCE_MID);
}

void addOnEvent(
    String ref, String event, String function, Object[] args, int precedence
) {
  String statementString = function2callableString(function, args);
  addOnEvent(ref, event, statementString);
}

void addOnEvent(String ref, String event, String function, Object[] args) {
  addOnEvent(ref, event, function, args, PRECEDENCE_MID);
}

void addOnEventCond(String ref, String event, String check, Object[] args) {
  String checkString = runnable2runnableString(check);
  addOnEvent(ref, event, checkString);
}

void bindOnEvent(String ref, String event) {
  String stmtsStr     = getStatementsString(ref, event);
  String focusStmtStr = getStatementsString(ref, "focus");
  String blurStmtStr  = getStatementsString(ref, "blur" );

  if (event.equals("load") && ref.equals("module")) {
    ;
  } else if (event.equals("focus")) {
    onFocus(ref, focusStmtStr, blurStmtStr);
  } else if (event.equals("blur" )) {
    onFocus(ref, focusStmtStr, blurStmtStr);
  } else if (!CUSTOM_EVENTS.contains(event)) {
    onEvent(ref, event, stmtsStr);
  } else {
    ; // Other events are implemented using auto-generated callback functions
  }
}

void bindOnEvents() {
  for (String key : ON_EVT_STMTS.keySet()) {
    refevent = key.split(SEP);
    ref   = refevent[0];
    event = refevent[1];
    bindOnEvent(ref, event);
  }
}

void onLeaveTab() {
  onLeaveTabGroup(getPreviouslyDisplayedTab());
}

/* Execute the "leave" event for the tab group at `ref` if a callback for it
 * exists.
 */
void onLeaveTabGroup(String ref) {
  String event    = "leave";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}

void onLeaveTabGroup() {
  onLeaveTabGroup(getPreviouslyDisplayedTabGroup());
}

/* Execute the "leave" event for the tab group at `ref` if a callback for it
 * exists.
 */
void onLeaveTabGroup(String ref) {
  String event    = "leave";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}

void incJobsTillLoaded() {
  NUM_JOBS_TILL_LOADED.incrementAndGet();
}

boolean isModuleLoaded() {
  return NUM_JOBS_TILL_LOADED.get() == 0;
}

/* Returns `true` if the module has loaded.
 */
boolean decJobsTillLoaded() {
  return NUM_JOBS_TILL_LOADED.decrementAndGet() == 0;
}

void decAndExecIfModuleLoaded() {
  if (decJobsTillLoaded())
    executeOnEvent("module", "load");
}

boolean isDoingFetchEvent() {
  return NUM_FETCHES_OCCURING.get() > 0;
}

/* Establishes `onEvent` bindings necessary to make the "leave" event work for
 * tab groups. The "leave" event is really triggered upon "show" of another tab
 * group.
 */
for (String ref : getTabGroups()) {
  String callback;

  // Update (previously) displayed tab group
  callback = fun2str("updateDisplayedTabGroup", ref);
  addOnEvent(ref, "show",   callback, PRECEDENCE_MAX);
  addOnEvent(ref, "create", callback, PRECEDENCE_MAX);

  // Trigger on leave tab group event
  callback = "onLeaveTabGroup()";
  addOnEvent(ref, "show", callback, PRECEDENCE_MAX);
}

/* Establishes `onEvent` bindings necessary to make the "leave" event work for
 * tabs. The "leave" event is really triggered upon "show" of another tab.
 */
for (String ref : getTabs()) {
  String callback;

  // Update (previously) displayed tab group
  callback = fun2str("updateDisplayedTab", ref);
  addOnEvent(ref, "show",   callback, PRECEDENCE_MAX);

  // Trigger on leave tab group event
  callback = "onLeaveTab()";
  addOnEvent(ref, "show", callback, PRECEDENCE_MAX);
}

for (String tg : getTabGroups()) {
  if (isFlaggedNodata(tg))
    continue;

  addOnEvent(
      tg,
      "prefetch",
      "NUM_FETCHES_OCCURING.incrementAndGet()",
      PRECEDENCE_MAX
  );
  addOnEvent(
      tg,
      "fetch",
      "NUM_FETCHES_OCCURING.decrementAndGet()",
      0
  );
}

/******************************************************************************/
/*                     LOCALSETTINGS VIEW/TABLE CREATION                      */
/******************************************************************************/
void makeLocalId(){
  fetchOne(
      "CREATE TABLE IF NOT EXISTS perflog (" +
      "    id              INTEGER PRIMARY KEY," +
      "    deviceModel     TEXT," +
      "    sessStartMs     INTEGER," +
      "    parentNameSpace TEXT," +
      "    srcLine         TEXT," +
      "    query           TEXT," +
      "    queryStartMs    INTEGER," +
      "    queryStopMs     INTEGER," +
      "    numAentvalue    INTEGER," +
      "    numArchentity   INTEGER," +
      "    numRelationship INTEGER," +
      "    numAentreln     INTEGER " +
      ")"
  );

  fetchOne(
      "CREATE TABLE IF NOT EXISTS localSettings (" +
      "    key   TEXT PRIMARY KEY," +
      "    value TEXT" +
      ")"
  );

  fetchOne(
      "DROP VIEW IF EXISTS parentchild"
  );

  fetchOne(
      "CREATE VIEW parentchild AS "+
      "           SELECT parent.uuid as parentuuid, child.uuid as childuuid, parent.participatesverb as parentparticipatesverb, parent.relationshipid, parent.aenttypename as parentaenttypename, child.participatesverb as childparticipatesverb, child.aenttypename as childaenttypename, createdat"+
      "             FROM (SELECT uuid, participatesverb, aenttypename, relationshipid, relntimestamp as createdat"+
      "                     FROM latestnondeletedaentreln "+
      "                     JOIN relationship USING (relationshipid) "+
      "                     JOIN latestnondeletedarchent USING (uuid) "+
      "                     JOIN aenttype USING (aenttypeid)) parent "+
      "             JOIN (SELECT uuid, relationshipid, participatesverb, aenttypename "+
      "                     FROM latestnondeletedaentreln "+
      "                     JOIN relationship USING (relationshipid) "+
      "                     JOIN latestnondeletedarchent USING (uuid) "+
      "                     JOIN aenttype USING (aenttypeid)) child "+
      "               ON (parent.relationshipid = child.relationshipid AND parent.uuid != child.uuid)"
  );
}
makeLocalId();

/******************************************************************************/
/*                            PERFORMANCE TESTING                             */
/*                                                                            */
/* Code to a) time queries; and b) create dummy records. (The vast majority   */
/* the code is for the latter.)                                               */
/******************************************************************************/
import android.database.DatabaseUtils;
import java.io.File;
import java.io.FileOutputStream;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.channels.ReadableByteChannel;
import java.nio.file.Files;
import java.text.DecimalFormat;
import java.util.concurrent.ConcurrentLinkedQueue;

ConcurrentLinkedQueue PERF_FILES             = new ConcurrentLinkedQueue();
AtomicInteger         PERF_NUM_CBS_DONE_FILE = null;
AtomicInteger         PERF_NUM_CBS_DONE_SAVE = null;
AtomicInteger         PERF_NUM_CBS_DONE_SET  = null;
AtomicInteger         PERF_NUM_CBS_TODO_FILE = null;
AtomicInteger         PERF_NUM_CBS_TODO_SAVE = null;
AtomicInteger         PERF_NUM_CBS_TODO_SET  = null;
boolean               PERF_ALLOW_CREATION    = false;
String                PERF_TEST_IMG          = "";
                      PERF_TYPE_TREE         = null;
int                   PERF_PHOTOS_PER_FIELD  = 1;

int getNumPhotos() {
  return getNumPhotos(PERF_TYPE_TREE);
}

int getNumPhotos(tree) {
  if (tree == null) return 0;

  int childSum = 0;
  for (child : tree.getChildren())
    childSum += getNumPhotos(child);

  boolean isRoot = isNull(tree.label);
  if (isRoot) return childSum;
  else        return childSum + getNumPhotosAtNode(tree);
}

int getNumPhotosAtNode(tree) {
  // Figure out how many camera refs there are at this node (i.e. in this arch
  // ent).
  List cameraRefs = getRefsByType("camera");
  List cameraRefsAtNode = new ArrayList();
  for (String ref : cameraRefs)
    if (getArchEntType(ref).equals(tree.label))
      cameraRefsAtNode.add(ref);

  return getNumDummyRecordsAtNode(tree) *
    cameraRefsAtNode.size() *
    PERF_PHOTOS_PER_FIELD;
}

int getNumDummyRecords() {
  getNumDummyRecords(PERF_TYPE_TREE);
}

int getNumDummyRecords(tree) {
  if (tree == null) return 0;

  int childSum = 0;
  for (child : tree.getChildren())
    childSum += getNumDummyRecords(child);

  boolean isRoot = isNull(tree.label);
  if (isRoot) return childSum;
  else        return childSum + getNumDummyRecordsAtNode(tree);
}

int getNumDummyRecordsAtNode(tree) {
  int sum = 1;
  for (; tree.getParent() != null; tree = tree.getParent()) {
    sum *= tree.data;
  }
  return sum;
}

Tree(String label, Object data) {
  String label    = label;
  Object data     = data;
         parent   = null;
  List   children;

  void addChild(tree) {
    if (super.children == null)
      super.children = new ArrayList();

    tree.setParent(super);
    super.children.add(tree);
  }

  getChild(int i) {
    return super.children.get(i);
  }

  int getIndex() {
    if (super.getParent() == null)
      return -1;
    return super.getParent().getChildren().indexOf(super);
  }

  getDescendant(String ref) {
    String[] refStrArr  = ref.split("/");
    List     refIntList = new ArrayList();

    for (String refStr : refStrArr) {
      int refInt = Integer.parseInt(refStr);
      refIntList.add(refInt);
    }

    return super.getDescendant(refIntList);
  }

  getDescendant(List ref) {
    if (ref.size() == 0)
      return super;

    int  head = ref.get(0);
    List tail = ref.subList(1, ref.size());

    if (ref.size() == 1) return getChild(head);
    if (ref.size() >= 2) return getChild(head).getDescendant(tail);
  }

  String getAncestorRefString(String sep, String key) {
    String s = "";
    for (Object n = super; n.getParent() != null; n = n.getParent()) {
      String val = "";
      if (key.equals("index")) val = n.getIndex() + "";
      if (key.equals("label")) val = n.label;

      s = sep + val + s;
    }

    if (!s.equals(""))
      s = s.substring(sep.length(), s.length()); // Remove initial `sep`

    return s;
  }

  String getAncestorRefString() {
    return getAncestorRefString("/", "index");
  }

  List getChildren() {
    if (super.children == null)
      return new ArrayList();
    return super.children;
  }

  int getNumNodes() {
    int sum = 1;
    for (child : super.getChildren())
      sum += child.getNumNodes();
    return sum;
  }

  void setParent(tree) {
    super.parent = tree;
  }

  getParent() {
    return super.parent;
  }

  String toString() {
    String s = "\n- " + super.label + " (" + data + ")";
    if (super.children != null)
      for (c : super.children)
        s += c.toString().replace("\n", "\n\t\t");
    return s;
  }

  return this;
}

TimedFetchCallback(String query, FetchCallback cb, int callerIdx) {
  int           callerIdx = callerIdx;
  String        query     = query;
  FetchCallback cb        = cb;
  bsh.CallStack cs_       = this.callstack.copy();

  long startTime = System.currentTimeMillis(); // Timer starts here
  long stopTime  = -1;

  void onFetch(Object result) {
    super.stopTimer();
    super.updatePerfLog();

    if (super.cb != null)
      super.cb.onFetch(result);
  }

  void onError(String message) {
    if (super.cb != null)
      super.cb.onError(message);
  }

  void stopTimer() {
    super.stopTime = System.currentTimeMillis();
  }

  double getElapsedMillis() {
    if (stopTime < 0)
      return -Double.MAX_VALUE;
    return super.stopTime - super.startTime;
  }

  void updatePerfLog() {
    String deviceModel     = android.os.Build.MODEL;
    String sessStartMs     = SESS_START_TIME + "";
    String parentNameSpace = cs_.get(callerIdx + 1).getName() + "";
    String srcLine         = cs_.get(callerIdx + 0).getInvocationLine() + "";
    String query           = query;
    String queryStartMs    = startTime + "";
    String queryStopMs     = stopTime + "";

    String updateQuery = "";
    updateQuery += " INSERT INTO perflog (";
    updateQuery += "             deviceModel,";
    updateQuery += "             sessStartMs,";
    updateQuery += "             parentNameSpace,";
    updateQuery += "             srcLine,";
    updateQuery += "             query,";
    updateQuery += "             queryStartMs,";
    updateQuery += "             queryStopMs,";
    updateQuery += "             numArchentity,";
    updateQuery += "             numAentvalue,";
    updateQuery += "             numRelationship,";
    updateQuery += "             numAentreln";
    updateQuery += " )    SELECT %s, %s, %s, %s, %s, %s, %s, a, av, r, ar";
    updateQuery += "        FROM";
    updateQuery += "             (SELECT COUNT(*) AS a  FROM archentity  ) a,";
    updateQuery += "             (SELECT COUNT(*) AS av FROM aentvalue   ) av,";
    updateQuery += "             (SELECT COUNT(*) AS r  FROM relationship) r,";
    updateQuery += "             (SELECT COUNT(*) AS ar FROM aentreln    ) ar";

    updateQuery = dbReplaceFirst(updateQuery, deviceModel);
    updateQuery = dbReplaceFirst(updateQuery, sessStartMs);
    updateQuery = dbReplaceFirst(updateQuery, parentNameSpace);
    updateQuery = dbReplaceFirst(updateQuery, srcLine);
    updateQuery = dbReplaceFirst(updateQuery, query);
    updateQuery = dbReplaceFirst(updateQuery, queryStartMs);
    updateQuery = dbReplaceFirst(updateQuery, queryStopMs);

    fetchOne(updateQuery);
  }

  return this;
}

void timedFetchOne(String q, FetchCallback cb, int callerIdx) {
  tcb = TimedFetchCallback(q, cb, callerIdx);
  fetchOne(q, tcb);
}

void timedFetchAll(String q, FetchCallback cb, int callerIdx) {
  tcb = TimedFetchCallback(q, cb, callerIdx);
  fetchAll(q, tcb);
}

void timedFetchOne(String q, FetchCallback cb) {
  timedFetchOne(q, cb, 2);
}

void timedFetchAll(String q, FetchCallback cb) {
  timedFetchAll(q, cb, 2);
}

void timedFetchOne(String q) {
  timedFetchOne(q, null, 2);
}

void timedFetchAll(String q) {
  timedFetchAll(q, null, 2);
}

void timedPopulateCursorList(String ref, String q, int limit) {
  String boundQ = q;
  boundQ = dbReplaceFirst(boundQ, "?", limit + "");
  boundQ = dbReplaceFirst(boundQ, "?", "0");
  timedFetchAll(boundQ, null, 2);

  populateCursorList(ref, q, limit);
}

void setUpTypeHierarchy() {
  //- 
  //  - Trip
  //    - Shellfish Aggregation

  n0 = Tree("", 1);
  n1 = Tree("Trip", 1);
  n2 = Tree("Shellfish Aggregation", 1);

  n0.addChild(n1);

  n1.addChild(n2);


  PERF_TYPE_TREE = n0;
}

setUpTypeHierarchy();

void saveEntitiesToPCRel(
    String parentType,
    String childType,
    String parentUuid,
    String childUuid
) {
    String relName = parentType + " - " + childType;
    String pOf     = "Parent Of";
    String cOf     = "Child Of";
    saveEntitiesToHierRel(relName, parentUuid, childUuid, pOf, cOf, "");
}

String randomMenuValue(String ref) {
  List vocabIds = getVocabIdsFromRef(ref);
  int  len      = vocabIds.size();
  if (len <= 0)
    return "";

  Random r   = new Random();
  int    i   = r.nextInt(len);

  return vocabIds.get(i);
}

String randomInputValue(String ref) {
  int len = 5;
  randomInputValue(ref, len);
}

String randomInputValue(String ref, int len) {
  if (getType(ref).equals("camera"))
    if (PERF_FILES.isEmpty()) {
      Log.e("randomInputValue()", "PERF_FILES empty, using empty string");
      return "";
    } else
      return PERF_FILES.poll();
  else
    return getRandomString(len);
}

List getAttribsForRef(String ref) {
  int numAttribs = 1;
  if (!hasData(ref))                 numAttribs = 0;
  if (hasMediaType(ref))             numAttribs = 0;
  if (getType(ref).equals("camera")) numAttribs = PERF_PHOTOS_PER_FIELD;

  List attribs = new ArrayList();
  for (int i = 0; i < numAttribs; i++) {
    String attribName = getAttributeName(ref);
    String annotation = "";
    String vocab      = "";
    String measure    = "";
    String certainty  = "1.0";

    if (hasMenuType(ref)) vocab   = randomMenuValue (ref);
    else                  measure = randomInputValue(ref);

    EntityAttribute ea = createEntityAttribute(
        attribName,
        annotation,
        vocab,
        measure,
        certainty
    );
    attribs.add(ea);
  }

  return attribs;
}

List getAttribsForArchEnt(String archEntType) {
  List attribs = new ArrayList();
  for (String ref : getRefs())
    if (getArchEntType(ref).equals(archEntType))
      attribs.addAll(getAttribsForRef(ref));

  return attribs;
}

void displayRecordDigest(int numCreated) {
  String q = "";
  q += "   SELECT '{All}', count(*)";
  q += "     FROM latestnondeletedarchent";
  q += "    UNION";
  q += "   SELECT aenttypename, count(*)";
  q += "     FROM latestnondeletedarchent";
  q += "     JOIN aenttype USING (aenttypeid)";
  q += " GROUP BY aenttypename";

  FetchCallback cb = new FetchCallback() {
    onFetch(result) {
      String head = "{perf_digest_1_head}";
      String body = "";
      if (numCreated >= 0)
        body += numCreated + " {perf_digest_1_body_1}";
      body += " {perf_digest_1_body_2}";

      if (result == null)
        result = new ArrayList();
      for (List row : result) {
        String type = row.get(0);
        String num  = row.get(1);

        body += "\t- " + type + ": " + num + "\n";
      }

      if (dialog != null)
        dialog.dismiss();
      showWarning(head, body);
    }
  };

  fetchAll(q, cb);
}

void displayRecordDigest() {
  displayRecordDigest(-1);
}

PerfSaveCallback(tree, String parentUuid) {
  tree              = tree;
  String parentUuid = parentUuid;

  saveRel(uuid) {
    parent            = super.tree.getParent();
    String parentUuid = super.parentUuid;

    if (parent == null || parentUuid == null)
      return;

    String parentType = parent    .label;
    String childType  = super.tree.label;

    saveEntitiesToPCRel(parentType, childType, parentUuid, uuid);
  }

  void onSave(String uuid, boolean newRecord) {
    int cbsDone = PERF_NUM_CBS_DONE_SAVE.incrementAndGet();
    int cbsTodo = PERF_NUM_CBS_TODO_SAVE.get();
    if (cbsTodo == cbsDone)
      displayRecordDigest(cbsDone);

    if (newRecord)
      super.saveRel(uuid);

    for (subtree : super.tree.getChildren())
      saveArchEnts(subtree, uuid);
  }

  void onError(String message) {
    if (dialog != null)
      dialog.dismiss();
    showWarning("Error", message);
  }

  return this;
}

void saveArchEnts(tree, String parentUuid) {
  String archEntName = tree.label;
  int    numEnts     = tree.data;
  cb                 = PerfSaveCallback(tree, parentUuid);

  for (int i = 0; i < numEnts; i++) {
    List attribs = getAttribsForArchEnt(archEntName);
    saveArchEnt(null, archEntName, (List) null, attribs, cb);
  }
}

void createDummyRecords() {
  int  n = getNumDummyRecords();
  dialog = showBusy("{perf_dummy_busy_head}", n + " {perf_dummy_busy_body}");

  enqueueTestFiles("createDummyRecordsRecursively()");
}

void createDummyRecordsRecursively() {
  int n = getNumDummyRecords();
  PERF_NUM_CBS_TODO_SAVE = new AtomicInteger(n);
  PERF_NUM_CBS_DONE_SAVE = new AtomicInteger(0);

  for (child : PERF_TYPE_TREE.getChildren())
    saveArchEnts(child, null);
}

void enqueueTestFiles(String cb) {
  enqueueTestFiles(getNumDummyRecords(), cb);
}

void enqueueTestFiles(int numFiles, String cb) {
  if (isNull(PERF_TEST_IMG)) {
    String head; String body;
    head  = "Record Creation Aborted";
    body  = "The master file from which test files are enqueued could not be ";
    body += "found on disk. Record creation cannot take place unless this file";
    body += " is present. Please ensure that your device is connected to the ";
    body += "internet, re-load the module, and try to run a create dummy ";
    body += "records again.";
    showWarning(head, body);
    return;
  }

  // Set `PERF_NUM_CBS_TODO_FILE` and `PERF_NUM_CBS_DONE_FILE`
  int numPhotosToMake;
  numPhotosToMake  = getNumPhotos();
  numPhotosToMake -= PERF_FILES.size();
  numPhotosToMake  = Math.max(0, numPhotosToMake);
  // We're going to count returns from attachFile too, hence multiplication by 2
  PERF_NUM_CBS_TODO_FILE = new AtomicInteger(numPhotosToMake + 1);
  PERF_NUM_CBS_DONE_FILE = new AtomicInteger(0);

  // Make records
  for (int i = 0; i < numPhotosToMake; i++) {
    String fileName = attachFile(
        PERF_TEST_IMG,
        false,
        null,
        fun2str("checkEnqueueTestFilesIsDone", cb)
    );

    PERF_FILES.add(fileName);
  }
  checkEnqueueTestFilesIsDone(cb);
}

void checkEnqueueTestFilesIsDone(String onDone) {
  int cbsDone = PERF_NUM_CBS_DONE_FILE.incrementAndGet();
  int cbsTodo = PERF_NUM_CBS_TODO_FILE.get();
  if (cbsTodo == cbsDone)
    execute(onDone);
}

PerfImageDownloader() {
  void run() {
    if (isInUnitTestTime())
      return;

    String filStr = "/sdcard/faims/modules/" + getModuleId() +
        "/files/app/test.jpg";
    String urlStr = "https://raw.githubusercontent.com/FAIMS/FAIMS-Tools/" +
        "master/test-images/construction-2894x1924.jpg";

    if (detectFile(filStr))
      return;

    try {
      URL           urlObj = new URL(urlStr);
      URLConnection urlCon = urlObj.openConnection();

      new File(filStr).getParentFile().mkdirs();

      InputStream      is  = urlCon.getInputStream();
      FileOutputStream fos = new FileOutputStream(filStr);

      byte[] buffer = new byte[4096];
      int len;

      // While we have availble data, continue downloading and storing to local
      // file
      while ((len = is.read(buffer)) > 0)
        fos.write(buffer, 0, len);

      if (is  != null) is .close();
      if (fos != null) fos.close();
    } catch (Exception e) {
      Log.e("PerfImageDownloader.run()", e.getMessage());
    }

    // Set `PERF_TEST_IMG` if the file was created successfully
    detectFile(filStr);
  }

  void start() {
    Runnable r = PerfImageDownloader();
    new Thread(r).start();
  }

  boolean detectFile(String filStr) {
    File newImg = new File(filStr);
    if (newImg.length() > 0) {
      PERF_TEST_IMG = filStr;
      return true;
    }
    return false;
  }

  return this;
}

void verifyEnableRecordCreation() {
  String q = "";
  q += " SELECT userid, fname, lname, email, password";
  q += "   FROM user";
  q += "  WHERE fname = 'Faims'";
  q += "    AND lname = 'Admin'";

  FetchCallback callback = new FetchCallback() {
    onFetch(result) {
      String userId    = result.get(0);
      String nameFirst = result.get(1);
      String nameLast  = result.get(2);
      String email     = result.get(3);
      String password  = result.get(4);

      User user = new User(userId, nameFirst, nameLast, email, password);
      setUser(user);

      showVerifyUserDialog("enableRecordCreation()");
    }
  };

  fetchOne(q, callback);
}

void enableRecordCreation() {
  PERF_ALLOW_CREATION = true;
  setUpPerfActionBarItems();

  showWarning("{perf_create_on_head}", "{perf_create_on_body}");
}

boolean isInPerfTestTime() {
  return false;
}

// Produce entity number specification
void setUpDummyRecordCreation() {
  int n = PERF_TYPE_TREE.getNumNodes()
      - 1; // Ignore root node

  PERF_NUM_CBS_TODO_SET = new AtomicInteger(n);
  PERF_NUM_CBS_DONE_SET = new AtomicInteger(0);

  setUpDummyRecordCreation(PERF_TYPE_TREE, "");
}

String getBreadCrumbs(node) {
  return node.getAncestorRefString(" › ", "label");
}

String typeToReadableType(String type) {
  if (type.equals("")) return "{this_module}";
  else                 return "{each} " + type;
}

void setUpDummyRecordCreation(tree, String parentType) {
  String type = tree.label;

  for (child : tree.getChildren())
    setUpDummyRecordCreation(child, type);

  if (!type.equals("")) {
    // Make head and body for `showTextAlert`
    String treeRef = tree.getAncestorRefString();
    String head    = getBreadCrumbs(tree);
    String body    = "{perf_rec_num_body_1} %s {perf_rec_num_body_2} %s " +
                     "{perf_rec_num_body_3}";
    body = replaceFirst(body, type);
    body = replaceFirst(body, typeToReadableType(parentType));

    promptSetDummyRecordQuantity(treeRef, head, body);
  }
}

void promptSetDummyRecordQuantity(String treeRef, String head, String body) {
  String cb = "setDummyRecordQuantity(\"%s\", \"%s\", \"%s\")";
  cb = replaceFirst(cb, treeRef);
  cb = replaceFirst(cb, head);
  cb = replaceFirst(cb, escape(body));

  showTextAlert(head, body, cb, "checkSetDummyRecordQuantityIsDone()");
}

void setDummyRecordQuantity(
    String treeRef,
    String failHead,
    String failBody
) {
  // Parse data as int
  int intData;
  try {
    intData = Integer.parseInt(getLastTextAlertInput());
  } catch (Exception e) {
    promptSetDummyRecordQuantity(treeRef, failHead, failBody);
    return;
  }

  PERF_TYPE_TREE.getDescendant(treeRef).data = intData;
  checkSetDummyRecordQuantityIsDone();
}

void checkSetDummyRecordQuantityIsDone() {
  int cbsDone = PERF_NUM_CBS_DONE_SET.incrementAndGet();
  int cbsTodo = PERF_NUM_CBS_TODO_SET.get();
  if (cbsTodo == cbsDone) {
    String totalRecs = getNumDummyRecords() + "";
    String treeString = PERF_TYPE_TREE.toString();
    String treeStringNoRoot = treeString.substring(
        "\n-  (1)".length(),
        treeString.length()
    );

    String head = "{perf_update_head}";
    String body =
         "{perf_update_body_1} " + treeStringNoRoot +
        " {perf_update_body_2} " + totalRecs +
        " {perf_update_body_3}";

    showAlert(head, body, "createDummyRecords()", "");
  }
}

void verifyCreateDummyRecords() {
  // Unless syncing is disabled, 'database locked' errors will happen
  setFileSyncEnabled(false);
  setSyncEnabled    (false);

  if (isSyncEnabled()) {
    showWarning("{perf_dummy_err_head}", "{perf_dummy_err_body}");
    return;
  }

  showAlert(
      "{perf_wiz_head}",
      "{perf_wiz_body}",
      "setUpDummyRecordCreation()",
      ""
  );
}

void setUpPerfActionBarItems() {
  removeActionBarItem("create_dummy_records");
  removeActionBarItem("display_record_digest");
  removeActionBarItem("enable_record_creation");

  String userMenuTabGroup = getTabGroupRef(USER_MENU_PATH);
  if (!isDisplayed(userMenuTabGroup)) {
    PERF_ALLOW_CREATION = false;
    return;
  }
  if (!isInPerfTestTime())
    return;

  ActionButtonCallback createDummyRecords = new ActionButtonCallback() {
      actionOnLabel() {
        "{create_dummy_records}";
      }
      actionOn() {
        verifyCreateDummyRecords();
      }
  };

  ActionButtonCallback displayRecordDigest = new ActionButtonCallback() {
      actionOnLabel() {
        "{display_record_digest}";
      }
      actionOn() {
        displayRecordDigest();
      }
  };

  ActionButtonCallback enableRecordCreation = new ActionButtonCallback() {
      actionOnLabel() {
        "{enable_record_creation}";
      }
      actionOn() {
        verifyEnableRecordCreation();
      }
  };

  // Careful! The `if` statements are weirdly formatted
  addActionBarItem("display_record_digest",  displayRecordDigest);
  if (PERF_ALLOW_CREATION)
  addActionBarItem("create_dummy_records",   createDummyRecords);
  if (!PERF_ALLOW_CREATION)
  addActionBarItem("enable_record_creation", enableRecordCreation);
}

void setUpPerfTestMode() {
  if (!isInPerfTestTime())
    return;

  // Download test image
  PerfImageDownloader().start();

  // Display performance testing notification
  showWarning("{perf_mode_head}", "{perf_mode_body}");
}

if (!isNull(USER_MENU_PATH)) {
  String userMenuTabGroup = getTabGroupRef(USER_MENU_PATH);

  setUpPerfTestMode();
  addOnEvent(userMenuTabGroup, "show",  "setUpPerfActionBarItems()");
  addOnEvent(userMenuTabGroup, "leave", "setUpPerfActionBarItems()");
}

/******************************************************************************/
/*                           LOCALSETTINGS UPDATES                            */
/******************************************************************************/
void insertIntoLocalSettings(String ref) {
  String val = getFieldValue(ref);
  insertIntoLocalSettings(ref, val);
}

void insertIntoLocalSettings(String key, String val, boolean doOverwrite) {
  if (val == null) val = "";

  String q;
  if (doOverwrite) q = "REPLACE INTO localSettings(key, value) VALUES(%s, %s)";
  else             q = "INSERT  INTO localSettings(key, value) VALUES(%s, %s)";

  q = dbReplaceFirst(q, key);
  q = dbReplaceFirst(q, val);
  fetchOne(q);
}

void insertIntoLocalSettings(String key, String val) {
  insertIntoLocalSettings(key, val, true);
}

void insertIntoLocalSettings(String key, Integer val) {
  insertIntoLocalSettings(key, Integer.toString(val));
}

void deleteFromLocalSettings(String key) {
  String q = "DELETE FROM localsettings WHERE key=%s";
  q = dbReplaceFirst(q, key);

  fetchOne(q);
}

void insertIntoLocalSettingsOnChange(String ref) {
  String val = getFieldValue(ref);

  String insertCallback = fun2str("insertIntoLocalSettings", ref);

  addOnEvent(ref, "blur",  insertCallback);
  addOnEvent(ref, "click", insertCallback);
}

void setFieldValueFromLocalSettings(
    String  key,
    String  ref,
    boolean doOverwrite,
    String defaultVal
) {
  String val = getFieldValue(ref);
  if (!isNull(val) && !doOverwrite) {
    return;
  }

  String q = "SELECT value FROM localSettings WHERE key = %s";
  q = dbReplaceFirst(q, key);

  FetchCallback set = new FetchCallback() {
    onFetch(result) {
      if (result != null && result.size() >= 1) {
        setFieldValue(ref, result.get(0));
      } else if (defaultVal != null) {
        setFieldValue(ref, defaultVal);
      }
    }
  };

  fetchOne(q, set);
}

void setFieldValueFromLocalSettings(
    String  key,
    String  ref,
    boolean doOverwrite
) {
  setFieldValueFromLocalSettings(key, ref, doOverwrite, null);
}

void setFieldValueFromLocalSettings(
    String  ref,
    boolean doOverwrite,
    String  defaultVal
) {
  setFieldValueFromLocalSettings(ref, ref, doOverwrite, defaultVal);
}

void setFieldValueFromLocalSettings(String ref, boolean doOverwrite) {
  setFieldValueFromLocalSettings(ref, ref, doOverwrite);
}

void setFieldValueFromLocalSettings(String key, String ref) {
  setFieldValueFromLocalSettings(key, ref, false);
}

void setFieldValueFromLocalSettings(String ref) {
  setFieldValueFromLocalSettings(ref, false);
}

void setFieldValueFromLocalSettingsOnEvent(
    String ref,
    boolean doOverwrite,
    String defaultVal,
    String event
) {
  String cb = fun2str(
      "setFieldValueFromLocalSettings",
      new Object[]{ref, doOverwrite, defaultVal}
  );

  addOnEvent(getTabGroupRef(ref), event, cb);
}

void setFieldValueFromLocalSettingsOnShow(
    String ref,
    boolean doOverwrite,
    String defaultVal
) {
  setFieldValueFromLocalSettingsOnEvent(ref, doOverwrite, defaultVal, "show");
}

void setFieldValueFromLocalSettingsOnShow(String ref, boolean doOverwrite) {
  setFieldValueFromLocalSettingsOnShow(ref, doOverwrite, (String) null);
}

/* Causes the value of the field given by `ref` to be saved each time it is
 * modified (on blur). The value of the field is restored when the tab group
 * containing the field is displayed.
 *
 * This function depends on `addOnEvent`. Therefore this function must be called
 * after `addOnEvent` is defined, but before `bindOnEvents` is called. This will
 * be so if the call is made in the autogenerator's `logic` tags.
 */
void persistOverSessions(String ref, boolean doOverwrite, String defaultVal) {
  String tabGroupRef = getTabGroupRef(ref);
  boolean isData = !isFlaggedNodata(tabGroupRef);

  String event;
  if (isData) event = "create";
  else        event = "show";

  setFieldValueFromLocalSettingsOnEvent(ref, doOverwrite, defaultVal, event);
  insertIntoLocalSettingsOnChange      (ref);
}

void persistOverSessions(String ref, boolean doOverwrite) {
  setFieldValueFromLocalSettingsOnShow(ref, doOverwrite);
  insertIntoLocalSettingsOnChange     (ref);
}

void persistOverSessions(String ref, String defaultVal) {
  persistOverSessions(ref, false, defaultVal);
}

void persistOverSessions(String ref) {
  persistOverSessions(ref, false, (String) null);
}



/******************************************************************************/
/*                           FIELD COPYING HELPERS                            */
/*                                                                            */
/* Provides an easy way to copy field values, even between vocabs.            */
/******************************************************************************/
boolean isSelected(String ref, String vocabName) {
  String vocabNameActual = getMenuValue(ref);

  if (vocabNameActual == null)
    return vocabNameActual == vocabName;
  else
    return vocabNameActual.equals(vocabName);
}

boolean setMenuValue(String ref, String vocabName) {
  String attrName = getAttributeName(ref);
  String vocabId = getVocabId(attrName, vocabName);

  if (isNull(vocabId))
    return false;

  setFieldValue(ref, vocabId);
  return isSelected(ref, vocabName);
}

boolean copyFieldValue(String src, String dst) {
  Boolean doFindVocabId = true;
  return copyFieldValue(src, dst, doFindVocabId);
}

/* `src`           The ref of the source field.
 * `dst`           The ref of the destination field.
 * `doFindVocabId` If this is true, and the properties/attributes of `src` and
 *                 `dst` are different, `copyFieldValue` treats `src` and `dst`
 *                 as if they were menus. Therefore, to copy the value seen by
 *                 the user (i.e. the vocabName of `src`), a database query is
 *                 performed. The query determines the which vocabId of `dst`
 *                 will make it display the same vocabName as `src`.
 *
 *                 If `doFindVocabId` is false, the value returned by
 *                 `getFieldValue` is copied, without any database accesses.
 */
boolean copyFieldValue(String src, String dst, Boolean doFindVocabId) {
  if (!doFindVocabId) {
    String valSrc = getFieldValue(src);
    setFieldValue(dst, valSrc);
    return true;
  }

  String valSrc;
  if (hasMenuType(src)) valSrc = getMenuValue (src);
  else                  valSrc = getFieldValue(src);

  if (hasMenuType(dst)) setMenuValue (dst, valSrc);
  else                  setFieldValue(dst, valSrc);

  String valDst;
  if (hasMenuType(dst)) valDst = getMenuValue (dst);
  else                  valDst = getFieldValue(dst);

  return valDst.equals(valSrc);
}

void clearField(String ref) {
  switch(getType(ref)) {
    case "dropdown": setFieldValue(ref, null); break;
    case "list":     return;
    default:         setFieldValue(ref, "");
  }
}

/* Copies the value from the field at `src` to the field at `dst` whenever the
 * a new record containing `dst` is created.
 *
 * `doCheckParent` If this is true, the value is only copied when the parent tab
 *                 group of the tab group referred to by `dst` is equal to the
 *                 tab group referred to by `src`. This is a way of checking
 *                 whether the field referred to by `src` has been loaded.
 * `doFindVocabId` Same as the `doFindVocabId` argument for the `copyFieldValue`
 *                 function.
 */
void inheritFieldValue(
    String src,
    String dst,
    boolean doCheckParent,
    boolean doFindVocabId
) {
  String fun = "";
  fun += "if (!{check} || getPreviouslyDisplayedTabGroup().equals(\"{parent}\"))";
  fun += "  copyFieldValue(\"{src}\", \"{dst}\", {find})";

  fun = replaceFirst(fun, "{check}",  doCheckParent + "");
  fun = replaceFirst(fun, "{parent}", getTabGroupRef(src));
  fun = replaceFirst(fun, "{src}",    src);
  fun = replaceFirst(fun, "{dst}",    dst);
  fun = replaceFirst(fun, "{find}",   doFindVocabId + "");


  String dstParent = getTabGroupRef(dst);
  if (isFlaggedNodata(dstParent)) addOnEvent(dstParent, "show",   fun);
  else                            addOnEvent(dstParent, "create", fun);
}

/* If `doCheckParent`, then the value at `src` will only be inherited to `dst`
 * if `getTabGroupRef(src)` was the previously displayed tab group.
 */
void inheritFieldValue(String src, String dst, boolean doCheckParent) {
  inheritFieldValue(src, dst, doCheckParent, true);
}

void inheritFieldValue(String src, String dst) {
  inheritFieldValue(src, dst, true);
}

inheritFieldValue("Trip/Trip_data/Subregion", "Shellfish_Aggregation/Shellfish_Type/Subregion", true);

/******************************************************************************/
/*                            NEW TAB REDIRECTION                             */
/*                                                                            */
/* Causes a call to `newTab("tab/path")` to take the user to the specified    */
/* tab.                                                                       */
/******************************************************************************/
void newTab(String ref, Boolean resolveTabs) {
  if (!resolveTabs) {
    newTab(ref);
    return;
  }

  if (isTab(ref))
    redirectTab = ref;

  String tabGroupRef = getTabGroupRef(ref);
  if (isDisplayed(tabGroupRef))
    resolveNewTab();
  else
    newTabGroup(tabGroupRef);
}

void resolveNewTab() {
  if (isNull(redirectTab))
    return;
  if (!isTab(redirectTab))
    return;

  newTab(redirectTab);
  redirectTab = "";
}

for (String ref : getTabGroups()) {
  addOnEvent(ref, "show", "resolveNewTab()");
}

/******************************************************************************/
/*                           DROPDOWN VALUE GETTER                            */
/*                                                                            */
/* For consistency with `getListItemValue()`.                                 */
/******************************************************************************/
String DROPDOWN_ITEM_VALUE = null;

String getDropdownItemValue() {
  return DROPDOWN_ITEM_VALUE;
}

for (entry : REF_TO_TYPE.entrySet()) {
  String type = entry.getValue();
  String ref  = entry.getKey();
  String evt  = "click";
  String stmt = "DROPDOWN_ITEM_VALUE = getFieldValue(\"%s\")";
  stmt = replaceFirst(stmt, ref);

  if (!type.equals("dropdown"))
    continue;
  if (hasNoUi(ref))
    continue;

  addOnEvent(ref, evt, stmt);
}

/******************************************************************************/
/*                              MENU POPULATION                               */
/******************************************************************************/
/* Deprecated: Fetches the contents of a specifed vocabulary and stores it in
 * the given list.
 */
void fetchVocab(String vocabName, List storageList) {
  fetchVocab(vocabName, storageList, null);
}

void fetchVocab(String vocabName, List storageList, String callbackFunction) {
  fetchAll("select vocabid, vocabname from vocabulary left join attributekey using (attributeid) where attributename = '" + vocabName + "';", new FetchCallback() {
    onFetch(result) {
      if (isNull(result))
        result = new ArrayList();

      storageList.addAll(result);
      Log.d("fetchVocab()", "Fetched vocabulary \"" + vocabname + "\" contents: " + result.toString());
      if (callbackFunction != null && !isNull(callbackFunction)) {
        execute(callbackFunction);
      }
    }
  });
}

/** Wrapper for to make a vocab without an exlusion list **/
String getMakeVocabType(String ref) {
  if (isHier(ref)) return "hierarchical" + getType(ref);
  else             return ""             + getType(ref);
}

void makeVocabs() {
  for (String ref : DATA_REFS)
    if (!hasNoUi(ref))
      makeVocab(ref);
  for (String ref : VP_REF_TO_REF.keySet())
    if (!hasNoUi(ref))
      makeVocab(ref);
}

void makeVocab(String ref) {
  if (!hasMenuType(ref))
    return;

  if (hasVpRef(ref))
    makeVocab(getMakeVocabType(ref), ref, getAttributeName(getVpRef(ref)));
  else
    makeVocab(getMakeVocabType(ref), ref, getAttributeName(ref));
}

void makeVocab(String type, String ref, String attrName) {
  makeVocab(type, ref, attrName, null);
}
void makeVocab(String type, String ref, String attrName, List vocabExclusions) {
    makeVocab(type, ref, attrName, vocabExclusions, null);
}

/* Populates the ref specified vocabulary from the database based on the given
 * attribute name, where type is the type of the vocab to populate (checkbox,
 * dropdown, hierarchicaldropdown, hierarchicalpicture, list, picture, radio).
 * */
void makeVocab(
    String type,
    String ref,
    String attrName,
    List   vocabExclusions,
    String callbackFunction
){
  if (
      isNull(type) ||
      isNull(ref) ||
      isNull(attrName)
  ) {
    Log.e(
        "makeVocab()",
        "Can't make populate vocab whose type, ref or attribute is null"
    );
    return;
  }

  if (!isModuleLoaded()) {
    String head = "Logic Error";
    String body = "makeVocab called before module loaded";
    showWarning(head, body);
    return;
  }

  // Make a filtered vocab
  List menuEntries = getMenuEntries(attrName);
  if (vocabExclusions == null) vocabExclusions = new ArrayList();

  List filteredVocab = new ArrayList();
  for(item : menuEntries) {
    if (vocabExclusions.contains(item.get(1))) {
      Log.d("makeVocab()", "removing vocab exclusion: " + item.get(1));
    } else {
      filteredVocab.add(item);
    }
  }

  // Determine whether to include a null option in the menu
  Boolean hasNull =
         !vocabExclusions.contains("")
      && !vocabExclusions.contains(null);

  // Populate menu
  populateMenu(type, ref, attrName, filteredVocab, hasNull);

  // Execute callback
  if (!isNull(callbackFunction))
    execute(callbackFunction);
}

boolean populateMenu(
    String  type,
    String  ref,
    String  attrName,
    List    entries,
    boolean hasNull
) {
  if (isNull(type))
    type = getMakeVocabType(ref);

  switch(type) {
    case "checkbox":
    case "CheckBoxGroup":
      populateCheckBoxGroup             (ref, entries);           break;
    case "dropdown":
    case "DropDown":
      populateDropDown                  (ref, entries, hasNull);  break;
    case "hierarchicaldropdown":
    case "HierarchicalDropDown":
      populateHierarchicalDropDown      (ref, attrName, hasNull); break;
    case "hierarchicalpicture":
    case "HierarchicalPictureGallery":
      populateHierarchicalPictureGallery(ref, attrName);          break;
    case "List":
    case "list":
      populateList                      (ref, entries);           break;
    case "picture":
    case "PictureGallery":
      populatePictureGallery            (ref, entries);           break;
    case "radio":
    case "RadioGroup":
      populateRadioGroup                (ref, entries);           break;
    default:
      Log.e(
          "populateMenu()",
          "Can't populate vocab; type '" + type + "' not recognised"
      );
      return false;
  }
  return true;
}

boolean populateMenu(String ref, List entries) {
  return populateMenu(null, ref, "", entries, true);
}

void populateMenu(String ref, String entry) {
  List entries  = new ArrayList();
  entries.add(new NameValuePair(entry, ""));

  populateMenu(ref, entries);
}

/******************************************************************************/
/*                             MENU VALUE GETTER                              */
/*                                                                            */
/* Provides simple ways of getting a menu's vocabname as opposed to the       */
/* default, which is the vocabid.                                             */
/******************************************************************************/
// Map from vocabid to vocabname. Populated by `fetchMenuValues()`.
Map VOCABID_TO_VOCABNAME        = new HashMap();
Map VOCABNAME_TO_VOCABID        = new HashMap();
Map ATTRIB_NAME_TO_VOCABIDS     = new HashMap();
Map ATTRIB_NAME_TO_MENU_ENTRIES = new HashMap();

void setVocabId(String attrName, String vocabName, String vocabId) {
  String key = attrName + SEP + vocabName;
  String val = vocabId;

  VOCABNAME_TO_VOCABID.put(key, val);
}

String getVocabId(String attrName, String vocabName) {
  return VOCABNAME_TO_VOCABID.get(attrName + SEP + vocabName);
}

void addVocabId(String attrName, String vocabId) {
  List vocabIds = ATTRIB_NAME_TO_VOCABIDS.get(attrName);
  if (vocabIds == null) {
    vocabIds = new ArrayList();
    ATTRIB_NAME_TO_VOCABIDS.put(attrName, vocabIds);
  }

  vocabIds.add(vocabId);
}

void addMenuEntry(
    String attrName,
    String vocabId,
    String vocabName,
    String picUrl
) {
  List menuEntries = ATTRIB_NAME_TO_MENU_ENTRIES.get(attrName);
  if (menuEntries == null) {
    menuEntries = new ArrayList();
    ATTRIB_NAME_TO_MENU_ENTRIES.put(attrName, menuEntries);
  }

  List menuEntry = new ArrayList();
  menuEntry.add(vocabId);
  menuEntry.add(vocabName);
  menuEntry.add(picUrl);

  menuEntries.add(menuEntry);
}

List getMenuEntries(String attrName) {
  List menuEntries = ATTRIB_NAME_TO_MENU_ENTRIES.get(attrName);
  if (menuEntries == null) return new ArrayList();
  else                     return menuEntries;
}

List getVocabIdsFromAttribName(String attribName) {
  List vocabIds = ATTRIB_NAME_TO_VOCABIDS.get(attribName);
  if (vocabIds == null) return new ArrayList();
  else                  return vocabIds;
}

List getVocabIdsFromRef(String ref) {
  String attribName = getAttributeName(ref);
  return getVocabIdsFromAttribName(attribName);
}

/*
 * Initialises `VOCABID_TO_VOCABNAME` with the (vocabid -> vocabname) mapping of
 * every menu.
 */
void fetchMenuValues() {
  String q = "";
  q += "   SELECT vocabid, vocabname, attributename, pictureurl";
  q += "     FROM vocabulary";
  q += "     JOIN attributekey USING (attributeid)";
  q += " ORDER BY vocabcountorder";

  FetchCallback populateHashMap = new FetchCallback() {
    onFetch(List result) {
      if (result == null)
        result = new ArrayList();

      for (List row : result) {
        String vocabId   = row.get(0);
        String vocabName = row.get(1);
        String attrName  = row.get(2);
        String picUrl    = row.get(3);

        // Populate VOCABID_TO_VOCABNAME
        VOCABID_TO_VOCABNAME.put(vocabId, vocabName);

        // Populate VOCABNAME_TO_VOCABID
        setVocabId(attrName, vocabName, vocabId);

        // Populate ATTRIB_NAME_TO_VOCABIDS
        addVocabId(attrName, vocabId);

        // Populate ATTRIB_NAME_TO_MENU_ENTRIES
        addMenuEntry(attrName, vocabId, vocabName, picUrl);
      }

      decAndExecIfModuleLoaded();
    }
  };

  incJobsTillLoaded();
  fetchAll(q, populateHashMap);
}

addOnEvent("module", "load", "makeVocabs()");
fetchMenuValues();

/* Returns a menu's vocabname, instead of the (counter-intuitive) vocabid.
 */
String getFieldValue(String ref, Boolean doConvertVocabIds) {
  if (!doConvertVocabIds) {
    return getFieldValue(ref);
  }

  String val       = getFieldValue(ref);
  String vocabName = VOCABID_TO_VOCABNAME.get(val);

  if (val       == null) return "";
  if (vocabName == null) return "";
  return vocabName;
}

/* Shorthand for writing getFieldValue(ref, true). This function's use is
 * discouraged in favour of writing `getFieldValue(ref, true)`.
 */
String getMenuValue(String ref) {
  return getFieldValue(ref, true);
}

HashMap NODATA_DROPDOWNS = new HashMap(); // ref -> menu entries
void addNodataDropdownEntry(String ref, String entryKey, String entryVal) {
  List menuEntries = NODATA_DROPDOWNS.get(ref);
  if (menuEntries == null) {
    menuEntries = new ArrayList();
    NODATA_DROPDOWNS.put(ref, menuEntries);
  }

  List menuEntry = new ArrayList();
  menuEntry.add(entryKey);
  menuEntry.add(entryVal);

  menuEntries.add(menuEntry);
}



for (entry : NODATA_DROPDOWNS.entrySet()) {
  String ref = entry.getKey();
  List   entries = entry.getValue();
  populateMenu(ref, entries);
}

/******************************************************************************/
/*                                  GPS/MAP                                   */
/******************************************************************************/


void updateGPSDiagnostics() {
  String diagnosticsRef = "";
  if (diagnosticsRef.equals("")) {
    return;
  }

  String status         = "";
  String previousStatus = getFieldValue(diagnosticsRef);
  String notInitialised = "{GPS_is_not_initialised}";

  // Check if GPS is initialised or was previously initialised.
  if (!isExternalGPSOn() && !isInternalGPSOn()) {
    if (!isNull(previousStatus) && !previousStatus.equals(notInitialised)) { // previous gps status is some last valid coordinate.
      // This is hackish. Arch16n substitution happens only at display-time, but the following if clause requires substitution to have happened at run-time
      String error = "";
      error = "{GPS_is_no_longer_initialised}. {Previous_status}:";
      setFieldValue(diagnosticsRef, error);   // Arch16n entry is substituted after this
      error = getFieldValue(diagnosticsRef);

      // check that error message wasn't previously appended to the previous status message.
      if (previousStatus.length()    >= error.length() &&
          previousStatus.subSequence(0, error.length()).equals(error)) {
        status = previousStatus;
      } else {
        status = error + "\n" + previousStatus;
      }
    } else {
      status = notInitialised;
    }
  } else {
    status += "{Internal_GPS}: ";
    if (isInternalGPSOn())
    {
      status += "{on}";
    } else {
      status += "{off}";
    }
    status += "\nExternal GPS: ";
    if (isExternalGPSOn())
    {
      if (isBluetoothConnected()) {
        status += "{on_and_bluetooth_connected}";
      } else {
        status += "{on_and_bluetooth_disconnected}";
      }
    } else {
      status += "{off}";
    }
    Object position = getGPSPosition();
    if (position != null) {
      Object projPosition = getGPSPositionProjected();
      status += "\n{Latitude}: " + position.getLatitude();
      status += "   {Longitude}: " + position.getLongitude();
      status += "\n{Northing}: " + projPosition.getLatitude();
      status += "   {Easting}: " + projPosition.getLongitude();
      status += "\n{Accuracy}: " + getGPSEstimatedAccuracy();
    } else {
      status += "\n{Position}: {no_GPS_position_could_be_found}";
    }
  }
  setFieldValue(diagnosticsRef, status);
}

final String MAP_CFG_PATH = "files/data/saved_config.json";


void loadMapSettings() {
  String filePath = getAttachedFilePath(MAP_CFG_PATH);

  if (!new File(filePath).exists())
    return;

  String toast = "showToast(\"{Loaded_Map_Configuration}\")";
  loadMapViewConfiguration(MAP_REF, filePath, toast);
}

void saveMapSettings() {
  String filePath = getAttachedFilePath(MAP_CFG_PATH);

  String toast = "showToast(\"{Saved_Map_Configuration}\")";
  saveMapViewConfiguration(MAP_REF, filePath, toast);
}

/******************************************************************************/
/*                                 ACTION BAR                                 */
/******************************************************************************/
addActionBarItem("clean_synced_files", new ActionButtonCallback() {
  actionOnLabel() {
    "{Clean_Synced_Files}";
  }
  actionOn() {
    cleanSyncedFiles();
  }
});

addActionBarItem("sync", new ToggleActionButtonCallback() {
  actionOnLabel() {
    "{Disable_Sync}";
  }
  actionOn() {
    setSyncEnabled(false);
    setFileSyncEnabled(false);
    showToast("{Sync_Disabled}");
  }
  isActionOff() {
    isSyncEnabled();
  }
  actionOffLabel() {
    "{Enable_Sync}";
  }
  actionOff() {
    setSyncEnabled(true);
    setFileSyncEnabled(true);
    showToast("{Sync_Enabled}");
  }
});

addActionBarItem("internal_gps", new ToggleActionButtonCallback() {
  actionOnLabel() {
    "{Disable_Internal_GPS}";
  }
  actionOn() {
    stopGPS();
    showToast("{Internal_GPS_Disabled}");
    updateGPSDiagnostics();
  }
  isActionOff() {
    isInternalGPSOn();
  }
  actionOffLabel() {
    "{Enable_Internal_GPS}";
  }
  actionOff() {
    if(isExternalGPSOn()) {
      stopGPS();
    }
    startInternalGPS();
    showToast("{Internal_GPS_Enabled}");
    updateGPSDiagnostics();
  }
});

addActionBarItem("external_gps", new ToggleActionButtonCallback() {
  actionOnLabel() {
    "{Disable_External_GPS}";
  }
  actionOn() {
    stopGPS();
    if (isBluetoothConnected()) {
      showToast("{External_GPS_Disabled}");
    } else {
      showToast("{Please_Enable_Bluetooth}");
    }
    updateGPSDiagnostics();
  }
  isActionOff() {
    isExternalGPSOn();
  }
  actionOffLabel() {
    "{Enable_External_GPS}";
  }
  actionOff() {
    if(isInternalGPSOn()) {
      stopGPS();
    }
    startExternalGPS();
    if(isBluetoothConnected()) {
      showToast("{External_GPS_Enabled}");
    } else {
      showToast("{Please_Enable_Bluetooth}");
      this.actionOn();
    }
    updateGPSDiagnostics();
  }
});

/******************************************************************************/
/*                                 USER LOGIN                                 */
/******************************************************************************/
boolean USER_MENU_IS_LOADED = false;

void populateListForUsers(){
  String q = "";
  q  = " SELECT          userid ";
  q += "        ||'\\0'||fname ";
  q += "        ||'\\0'||lname ";
  q += "        ||'\\0'||email ";
  q += "        ||'\\0'||password ";
  q += "        ,        fname ";
  q += "        || ' ' ||lname ";
  q += "   FROM user ";
  q += "  WHERE userdeleted is null";


  FetchCallback callback = new FetchCallback() {
    onFetch(result) {
      populateMenu(USER_MENU_PATH, result);
      USER_MENU_IS_LOADED = true;
    }
  };

  USER_MENU_IS_LOADED = false;
  populateMenu(USER_MENU_PATH, MSG_LOADING);
  fetchAll(q, callback);
}

String getUserMenuValue(int i) {
  String selectedUser = getFieldValue(USER_MENU_PATH);
  if (selectedUser == null)
    return "";

  String[] splitted = selectedUser.split("\\\\0");
  if (i < splitted.length) return splitted[i];
  else                     return "";

}

void resetUser() {
  userId   = "";
  username = "";
  User user = new User(userId, "", "", "", "");
  setUser(user);
}

void selectUser() {
  userId           = getUserMenuValue(0);
  String nameFirst = getUserMenuValue(1);
  String nameLast  = getUserMenuValue(2);
  String email     = getUserMenuValue(3);
  String password  = getUserMenuValue(4);
  username         = nameFirst + " " + nameLast;

  User user = new User(userId, nameFirst, nameLast, email, password);
  setUser(user);
}

void onClickSignup__ () {
  setSyncEnabled(true);
  showCreateUserDialog("onSignupSuccessful()");
}

void onSignupSuccessful() {
  showWarning("{signup_head}", "{signup_body}");
  populateListForUsers();
}

if (!isNull(USER_MENU_PATH)) {
  addOnEvent(getTabGroupRef(USER_MENU_PATH), "show", "resetUser()");

  addOnEvent(USER_MENU_PATH, "show",  "populateListForUsers()");
  addOnEvent(USER_MENU_PATH, "click", "selectUser()");

  addOnEventCond(USER_MENU_PATH, "click", "USER_MENU_IS_LOADED");
}

addOnEvent("Login/User_login/Sign_up", "click", "onClickSignup__()");

/******************************************************************************/
/*                                 VALIDATION                                 */
/******************************************************************************/
/* `ref`  is a reference/ref to a field
 * `name` is a human-readable name for that field
 * `cond` is a String containing a boolean expression that evaluates to true if
 *        and only if the the field pair returned by this function should be
 *        validated.
 *
 *  Returns a field pair (really just an ArrayList).
 */
List fieldPair(String ref, String name, String cond) {
  List fp = new ArrayList();
  fp.add(ref);
  fp.add(name);
  fp.add(cond);
  return fp;
}

List fieldPair(String ref, String name) {
  String t = "true";
  return fieldPair(ref, name, t);
}

/* Returns true if field specified by `ref` is valid. False otherwise.
 */
boolean isValidField(String ref) {
  return !isNull(getFieldValue(ref));
}
/* `format` can either be HTML or PLAINTEXT
 */
String validateFields(List fields, String format) {
  Integer numInvalid = 0;

  /* Build validation message string (and count how many invalid fields exist) */
  String out = "{please_fill_out_the_following_fields}";
  for(f : fields) {
    String ref  = f.get(0); // Reference to field
    String name = f.get(1); // Human-readable name
    String cond = f.get(2); // Validation condition

    // Only validate a field whose validation condition evaluates to `true`
    Boolean doValidateField = (Boolean) eval(cond);
    if (!doValidateField)
      continue;

    // Add any invalid fields to the output and tally them
    if (!isValidField(ref)) {
      out += "- " + name + "\n";
      numInvalid++;
    }
  }
  // All the fields are valid; just overwrite `out` with a cheery message
  if (numInvalid == 0)
    out = "{all_fields_contain_valid_data}";

  /* Format the output as dictated by `format` */
  if (format == "HTML") {
    out = out.replace("\n", "<br>");
  } else if (format == "PLAINTEXT") {
    ;
  }

  return out;
}

void validateTrip() {
  List f = new ArrayList(); // Fields to be validated
  f.add(fieldPair("Trip/Trip_data/Subregion", "{Subregion}"));
  f.add(fieldPair("Trip/Shoreline_attributes/Natural_habitat_types", "{Natural_habitat_types}"));
  f.add(fieldPair("Trip/Shoreline_attributes/Artificial_habitat_types", "{Artificial_habitat_types}"));
  f.add(fieldPair("Trip/Shoreline_attributes/Dominant_habitat", "{Dominant_habitat}"));
  f.add(fieldPair("Trip/Shoreline_attributes/Adjacent_land_use", "{Adjacent_land_use}"));
  f.add(fieldPair("Trip/Shoreline_attributes/Wastewater_outflows", "{Wastewater_outflows}"));
  f.add(fieldPair("Trip/Shoreline_attributes/Habitat_photo", "{Habitat_photo}"));
  f.add(fieldPair("Trip/Shoreline_attributes/Animals_present", "{Animals_present}"));
  f.add(fieldPair("Trip/Shoreline_attributes/Shoreline_slope", "{Shoreline_slope}"));

  String validationMessage = validateFields(f, "PLAINTEXT");
  showWarning("{validation_results}", validationMessage);
}


/******************************************************************************/
/*                                 AUTOSAVING                                 */
/******************************************************************************/
Map TABGROUP_TO_UUID = Collections.synchronizedMap(new HashMap());
Set SEEN_UUIDS       = Collections.synchronizedSet(new HashSet());

String getUuid(String tabgroup) {
  return TABGROUP_TO_UUID.get(tabgroup);
}

String getUuid() {
  return getUuid(getDisplayedTabGroup());
}

void setUuid(String tabgroup, String uuid) {
  TABGROUP_TO_UUID.put(tabgroup, uuid);
}

void saveTabGroup(String tabgroup) {
  saveTabGroup(tabgroup, "");
}

void saveTabGroup(String tabgroup, String callback) {
  Boolean enableAutosave      = true;
  String  id                  = getUuid(tabgroup);
  String  parentTabgroup_     = parentTabgroup;
  String  parentTabgroupUuid_ = getUuid(parentTabgroup_);
  Boolean userWasSet          = !username.equals("");

  callback += "; " + fun2str("executeOnEvent", new Object[]{tabgroup, "save"});
  callbackFirstSave =
    fun2str("executeOnEvent", new Object[]{tabgroup, "firstsave"}) + "; " +
    callback;

  parentTabgroup = null;

  SaveCallback saveCallback  = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);

      // This is a workaround for a bug where `newRecord` can be `true` twice if
      // a record was saved again shortly after it was created.
      if (SEEN_UUIDS.contains(uuid))
        newRecord = false;
      if (uuid != null)
        SEEN_UUIDS.add(uuid);

      String cb = newRecord ? callbackFirstSave : callback;

      // Make a child-parent relationship if need be.
      if (
          newRecord &&
          !isNull(parentTabgroup_) &&
          !isNull(parentTabgroupUuid_)
      ) {
        String rel = "";
        rel += parentTabgroup_.replaceAll("_", " ");
        rel += " - ";
        rel += tabgroup.replaceAll("_", " ");
        saveEntitiesToHierRel(
          rel,
          parentTabgroupUuid_,
          uuid,
          "Parent Of",
          "Child Of",
          cb
        );
      } else {
        execute(cb);
      }

      // This fixes an interesting bug. Without this, if a user was not set
      // (by calling `setUser`) at the time `saveTabGroup` was first called, but
      // set by the time `onSave` was called, the tab group is saved correctly
      // the first time only.
      //
      // Adding this allows subsequent saves to succeed. Presumably it plays
      // some role in helping FAIMS associate the correct user with a record.
      if (!userWasSet) {
        saveTabGroup(tabgroup, cb);
      }

    }
    onError(message) {
      showToast(message);
    }
  };

  saveTabGroup(
      tabgroup,
      id,
      autoSaveGeo,
      autoSaveAttrs,
      saveCallback,
      enableAutosave
  );

  // Reset global variables
  autoSaveGeo   = null;
  autoSaveAttrs = null;
}

void setAutoSaveGeometry(List geometry) {
  autoSaveGeo = geometry;
}

void setToTimestampNow(String ref) {
  String now = getTimestampNow();
  setFieldValue(ref, now);
}

String getTimestampNow() {
  String fmt = "yyyy-MM-dd HH:mm:ssZ";
  return getTimestampNow(fmt);
}

String getTimestampNow(String fmt, boolean doInsertColon) {
  date    = new Date();
  dateFmt = new java.text.SimpleDateFormat(fmt);
  dateStr = dateFmt.format(date);

  // Insert colon into timezone (e.g. +1000 -> +10:00)
  if (doInsertColon) {
    String left; String right;

    left    = dateStr.substring(0, dateStr.length() - 2);
    right   = dateStr.substring(   dateStr.length() - 2);
    dateStr = left + ":" + right;
  }

  return dateStr;
}

String getTimestampNow(String fmt) {
  return getTimestampNow(fmt, true);
}

void populateAuthorAndTimestamp(String tabgroup) {
  Map tabgroupToAuthor    = new HashMap();
  Map tabgroupToTimestamp = new HashMap();
  tabgroupToAuthor.put("Trip", "Trip/Trip_data/Trip_author");
  
  String authorPath    = tabgroupToAuthor.get(tabgroup);
  String timestampPath = tabgroupToTimestamp.get(tabgroup);

  if (!isNull(authorPath))    setFieldValue(authorPath,    username);
  if (!isNull(timestampPath)) setFieldValue(timestampPath, getTimestampNow());
}

void onShowTrip () {
  saveTabGroup("Trip");
}

void onShowShellfishAggregation () {
  saveTabGroup("Shellfish_Aggregation");
}

addOnEvent("Trip", "show", "onShowTrip()");
addOnEvent("Shellfish_Aggregation", "show", "onShowShellfishAggregation()");

void onClickLoginGotoLoginTab () {
  newTab("Login/User_login", true);
}

void onClickGeneralStartRecording () {
  newTab("General/General", true);
}

void onClickGeneralStartTrip () {
  parentTabgroup__ = "General";
  newTrip();
}

void onValidClickLoginLogin () {
  newTab("General", true);
}



void onClickLoginLogin () {
  showVerifyUserDialog("onValidClickLoginLogin()");
}

void onClickTripAddShellfishAggregation () {
  newShellfishAggregation("Trip");
}
addOnEvent("Login/Manual/Go_to_Login_Tab", "click", "onClickLoginGotoLoginTab()");
addOnEvent("General/General/Start_Trip", "click", "onClickGeneralStartTrip()");
addOnEvent("General/Manual/Start_Recording", "click", "onClickGeneralStartRecording()");
addOnEvent("Login/User_login/Log_in", "click", "onClickLoginLogin()");
addOnEvent("Trip/Shellfish_Aggregation/Add_Shellfish_Aggregation", "click", "onClickTripAddShellfishAggregation()");

/******************************************************************************/
/*                   AUDIO, CAMERA, FILE AND VIDEO BINDINGS                   */
/******************************************************************************/
addOnEvent("Trip/Shoreline_attributes/Habitat_photo_Button_1", "click", "attachPictureTo(\"Trip/Shoreline_attributes/Habitat_photo\")");
addOnEvent("Shellfish_Aggregation/Shellfish_Type/Shellfish_Photo_Button_1", "click", "attachPictureTo(\"Shellfish_Aggregation/Shellfish_Type/Shellfish_Photo\")");
addOnEvent("Shellfish_Aggregation/Aggregation_Attributes/Aggregation_Photos_Button_1", "click", "attachPictureTo(\"Shellfish_Aggregation/Aggregation_Attributes/Aggregation_Photos\")");

/******************************************************************************/
/*                 BINDINGS FOR 'VIEW ATTACHED FILES' BUTTONS                 */
/******************************************************************************/


/******************************************************************************/
/*                             NAVIGATION DRAWER                              */
/******************************************************************************/
void removeNavigationButtons() {
  removeNavigationButton("new");
  removeNavigationButton("duplicate");
  removeNavigationButton("delete");
  removeNavigationButton("validate");
}

void addNavigationButtons(String tabgroup) {
  removeNavigationButtons();
  List tabgroupsToValidate = new ArrayList();
  tabgroupsToValidate.add("Trip");
  addNavigationButton("new", new ActionButtonCallback() {
    actionOnLabel() {
      "{New}";
    }
    actionOn() {
      if(isNull(getUuid(tabgroup))) {
        showAlert(
            "{Warning}",
            "{The_current_record_has_not_been_saved_yet}",
            fun2str("newRecord", new Object[]{tabgroup, true}),
            ""
        );
      } else {
        newRecord(tabgroup, true);
        showToast("{New_record_created}");
      }
    }
  }, "success");
  addNavigationButton("duplicate", new ActionButtonCallback() {
    actionOnLabel() {
      "{Duplicate}";
    }
    actionOn() {
      if(!isNull(getUuid(tabgroup))) {
        duplicateRecord(tabgroup);
      } else {
        showWarning("{Warning}", "{This_record_is_unsaved_and_cannot_be_duplicated}");
      }
    }
  }, "primary");
  addNavigationButton("delete", new ActionButtonCallback() {
    actionOnLabel() {
      "{Delete}";
    }
    actionOn() {
      deleteRecord(tabgroup);
    }
  }, "danger");
  if (tabgroupsToValidate.contains(tabgroup)) {
    addNavigationButton("validate", new ActionButtonCallback() {
      actionOnLabel() {
        "{Validate}";
      }
      actionOn() {
        String validationFunction = "validate" + tabgroup.replaceAll("_", "") + "()";
        eval(validationFunction);
      }
    }, "default");
  }
}

/******************************************************************************/
/*        ENTITY AND RELATIONSHIP SAVING AND LOADING HELPER FUNCTIONS         */
/******************************************************************************/
/** Saves two entity id's as a relation. **/
void saveEntitiesToRel(String type, String entity1, String entity2) {
  String callback = null;
  saveEntitiesToRel(type, entity1, entity2, callback);
}

/** Saves two entity id's as a relation with some callback executed. **/
void saveEntitiesToRel(String type, String entity1, String entity2, String callback) {
  String e1verb = null;
  String e2verb = null;
  saveEntitiesToHierRel(type, entity1, entity2, e1verb, e2verb, callback);
}

/** Saves two entity id's as a hierachical relation with some callback executed. **/
void saveEntitiesToHierRel(String type, String entity1, String entity2, String e1verb, String e2verb, String callback) {
  if (isNull(entity1) || isNull(entity2)) return;

  SaveCallback execCallback = new SaveCallback() {
    onSaveAssociation(entity_id, rel_id) {
      if(!isNull(callback)) {
         execute(callback);
      }
    }
    onError(message) {
      Log.e("saveEntitiesToHierRel", message);
      showToast(message);
    }
  };

  SaveCallback addMoreToRel = new SaveCallback() {
    onSaveAssociation(entity_id, rel_id) {
      addReln(entity2, rel_id, e2verb, execCallback);
    }
    onError(message) {
      Log.e("saveEntitiesToHierRel", message);
      showToast(message);
    }
  };

  SaveCallback addToRel = new SaveCallback() {
    onSave(rel_id, newRecord) {
      addReln(entity1, rel_id, e1verb, addMoreToRel);
    }
    onError(message) {
      Log.e("saveEntitiesToHierRel", message);
      showToast(message);
    }
  };

  saveRel(null, type, null, null, addToRel);
}

// Makes a new record of the given tabgroup
void newRecord(String tabgroup) {
  boolean doUpdateRelVars = false;
  newRecord(tabgroup, doUpdateRelVars);
}

void newRecord(String tabgroup, String parentTabGroup) {
  parentTabgroup   = parentTabGroup;
  parentTabgroup__ = parentTabGroup;
  newRecord(tabgroup, false);
}

void newRecord(String tabgroup, boolean doUpdateRelVars) {
  if (doUpdateRelVars) {
    String uuidOld = getUuid(getDisplayedTabGroup());
    String q       = getDuplicateRelnQuery(uuidOld); // We're not duplicating
                                                     // anything, just getting
                                                     // the parent's UUID.

    cancelTabGroup(tabgroup, false);

    FetchCallback updateRelVars = new FetchCallback() {
      onFetch(result) {
        if (result != null && result.size() >= 1) {
          parentTabgroup   = result.get(0).get(4);
          parentTabgroup   = parentTabgroup.replaceAll(" ", "_");
          parentTabgroup__ = parentTabgroup;
        }

        newRecord(tabgroup, false);
      }
    };
    fetchAll(q, updateRelVars);
    return;
  }

  String newTabGroupFunction = "new" + tabgroup.replaceAll("_", "") + "()"; // Typical value: "newTabgroup()"
  eval(newTabGroupFunction);

  Log.d("newRecord", tabgroup);
}

// Deletes the current record of the given tabgroup
void deleteRecord(String tabgroup) {
  if (isNull(getUuid(tabgroup))) {
    cancelTabGroup(tabgroup, true);
  } else {
    showAlert(
        "{Confirm_Deletion}",
        "{Press_OK_to_Delete_this_Record}",
        fun2str("reallyDeleteRecord", tabgroup),
        "doNotDelete()"
    );
  }

  Log.d("deleteRecord", tabgroup);
}

void reallyDeleteRecord(String tabgroup) {
  DeleteCallback callback = new DeleteCallback() {
    onDelete(uuid) {
      populateEntityListsOfArchEnt(tabgroup);
      executeOnEvent(tabgroup, "delete");
    }

    onError(message) {
      showToast(message);
    }
  };

  deleteArchEnt(getUuid(tabgroup), callback);
  cancelTabGroup(tabgroup, false);
}

// Duplicates the current record of the given tabgroup
void duplicateRecord(String tabgroup) {
  dialog = showBusy("Duplicating", "Please wait...");

  String duplicateTabGroupFunction = "duplicate" + tabgroup.replaceAll("_", "") + "()"; // Typical value: "duplicateTabgroup()"
  eval(duplicateTabGroupFunction);

  Log.d("duplicateRecord", tabgroup);
}

// generic fetch saved attributes query
String getDuplicateAttributeQuery(String originalRecordID, String attributesToDupe) {
  if (attributesToDupe.equals("")) {
    attributesToDupe = "''";
  }
  String duplicateQuery = "SELECT attributename, freetext, vocabid, measure, certainty " +
                          "  FROM latestnondeletedaentvalue JOIN attributekey USING (attributeid) " +
                          " WHERE attributename IN ('', "+attributesToDupe+") " +
                          "   AND uuid = '"+originalRecordID+"'; ";
  return duplicateQuery;
}

String getDuplicateRelnQuery(String originalRecordID) {
  String dupeRelnQuery = "SELECT relntypename, parentparticipatesverb, childparticipatesverb, parentuuid, parentaenttypename, childaenttypename"+
                         "  FROM parentchild join relationship using (relationshipid) "+
                         "  JOIN relntype using (relntypeid) "+
                         " WHERE childuuid = '"+originalRecordID+"' " +
                         "   AND parentparticipatesverb = 'Parent Of' ";
  return dupeRelnQuery;
}

void makeDuplicateRelationships(fetchedAttributes, String newUuid){
  Log.e("Module", "makeDuplicateRelationships");
  for (savedAttribute : fetchedAttributes){
    String relntypename           = savedAttribute.get(0);
    String parentparticipatesverb = savedAttribute.get(1);
    String childparticipatesverb  = savedAttribute.get(2);
    String parentUuid             = savedAttribute.get(3);
    String childArchEntType       = savedAttribute.get(5);

    String onSaveRel              = getStatementsString(
        childArchEntType.replaceAll(" ", "_"),
        "save"
    );

    saveEntitiesToHierRel(
        relntypename,
        parentUuid,
        newUuid,
        parentparticipatesverb,
        childparticipatesverb,
        onSaveRel
    );
  }
}

// generic get extra attributes
List getExtraAttributes(fetchedAttributes) {
  List extraAttributes = createAttributeList();
  Log.d("Module", "Duplicating fetched attributes: " + fetchedAttributes.toString());
  for (savedAttribute : fetchedAttributes) {
    extraAttributes.add(
      createEntityAttribute(
        savedAttribute.get(0),
        savedAttribute.get(1),
        savedAttribute.get(2),
        savedAttribute.get(3),
        savedAttribute.get(4)
      )
    );
  }
  return extraAttributes;
}

void loadEntity() {
  loadEntity(false);
}
void loadEntity(Boolean isDropdown) {
  if (isDropdown) {
    loadEntityFrom(getDropdownItemValue());
  } else {
    loadEntityFrom(getListItemValue());
  }
}

void loadEntityFrom(String entityID) {
  loadEntityFrom(entityID, "");
}

void loadEntityFrom(String entityID, String onFail) {
  if (isNull(entityID)) {
    return;
  }

  String getEntTypeNameQ = "SELECT aenttypename " +
                           "  FROM latestnondeletedarchent " +
                           "  JOIN aenttype " +
                           " USING (aenttypeid) " +
                           " WHERE uuid = '" + entityID + "'";
  fetchAll(getEntTypeNameQ, new FetchCallback() {
    onFetch(result) {
      if (
          result               == null ||
          result       .size() == 0    ||
          result.get(0).size() == 0
      ) {
        String head  = "{err_load_entity_head}";
        String body  = "{err_load_entity_body}";
        showWarning(head, body);
        execute(onFail);
        return;
      }

      String archEntName = result.get(0).get(0).replaceAll(" ", "");
      String loadFunction = "load" + archEntName + "From(entityID)"; // Typical value: loadContextFrom(entityID)
      eval(loadFunction);
    }
  });
}


void newTrip(String parent){
  String tabgroup = "Trip";
  if (!isNull(parent)) {
    triggerAutoSave();
    parentTabgroup   = parent;
    parentTabgroup__ = parent;
  }
  

  setUuid(tabgroup, null);
  newTabGroup(tabgroup);
  populateAuthorAndTimestamp(tabgroup);
  populateEntityListsInTabGroup(tabgroup);
  

  executeOnEvent(tabgroup, "create");
}

void newTrip (){
  newTrip(null);
}

void newShellfishAggregation(String parent){
  String tabgroup = "Shellfish_Aggregation";
  if (!isNull(parent)) {
    triggerAutoSave();
    parentTabgroup   = parent;
    parentTabgroup__ = parent;
  }
  

  setUuid(tabgroup, null);
  newTabGroup(tabgroup);
  populateAuthorAndTimestamp(tabgroup);
  populateEntityListsInTabGroup(tabgroup);
  

  executeOnEvent(tabgroup, "create");
}

void newShellfishAggregation (){
  newShellfishAggregation(null);
}
void duplicateTrip(){
  String tabgroup = "Trip";
  String uuidOld = getUuid(tabgroup);
  setUuid(tabgroup, "");
  disableAutoSave(tabgroup);
  
  clearGpsInTabGroup(tabgroup);
  populateAuthorAndTimestamp(tabgroup);
  populateEntityListsInTabGroup(tabgroup);
  populateCameraPictureGallery("Trip/Shoreline_attributes/Habitat_photo", new ArrayList());
  executeOnEvent(tabgroup, "copy");

  saveCallback = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);

      fetchAll(getDuplicateRelnQuery(uuidOld), new FetchCallback(){
        onFetch(result) {
          Log.e("Module", result.toString());

          if (result != null && result.size() >= 1) {
            parentTabgroup__ = result.get(0).get(4);
            parentTabgroup__ = parentTabgroup__.replaceAll(" ", "_");
          }

          makeDuplicateRelationships(result, getUuid(tabgroup));

          showToast("{Duplicated_record}");
          dialog.dismiss();
        }
      });

      saveTabGroup(tabgroup);
    }
  };

  String extraDupeAttributes = "";
  fetchAll(getDuplicateAttributeQuery(uuidOld, extraDupeAttributes), new FetchCallback(){
    onFetch(result) {
      excludeAttributes = new ArrayList();

      excludeAttributes.add("Habitat photo");

      duplicateTabGroup(tabgroup, null, getExtraAttributes(result), excludeAttributes, saveCallback);
    }
  });
}
void duplicateShellfishAggregation(){
  String tabgroup = "Shellfish_Aggregation";
  String uuidOld = getUuid(tabgroup);
  setUuid(tabgroup, "");
  disableAutoSave(tabgroup);
  
  clearGpsInTabGroup(tabgroup);
  populateAuthorAndTimestamp(tabgroup);
  populateEntityListsInTabGroup(tabgroup);
  populateCameraPictureGallery("Shellfish_Aggregation/Shellfish_Type/Shellfish_Photo", new ArrayList());
  populateCameraPictureGallery("Shellfish_Aggregation/Aggregation_Attributes/Aggregation_Photos", new ArrayList());
  executeOnEvent(tabgroup, "copy");

  saveCallback = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);

      fetchAll(getDuplicateRelnQuery(uuidOld), new FetchCallback(){
        onFetch(result) {
          Log.e("Module", result.toString());

          if (result != null && result.size() >= 1) {
            parentTabgroup__ = result.get(0).get(4);
            parentTabgroup__ = parentTabgroup__.replaceAll(" ", "_");
          }

          makeDuplicateRelationships(result, getUuid(tabgroup));

          showToast("{Duplicated_record}");
          dialog.dismiss();
        }
      });

      saveTabGroup(tabgroup);
    }
  };

  String extraDupeAttributes = "";
  fetchAll(getDuplicateAttributeQuery(uuidOld, extraDupeAttributes), new FetchCallback(){
    onFetch(result) {
      excludeAttributes = new ArrayList();

      excludeAttributes.add("Shellfish Photo");
      excludeAttributes.add("Aggregation Photos");

      duplicateTabGroup(tabgroup, null, getExtraAttributes(result), excludeAttributes, saveCallback);
    }
  });
}
addOnEvent("Trip", "save", "populateEntityListsOfArchEnt(\"Trip\")");
addOnEvent("Shellfish_Aggregation", "save", "populateEntityListsOfArchEnt(\"Shellfish_Aggregation\")");

void doNotDelete(){
  showToast("{Delete_Cancelled}");
}

addOnEvent("Login", "show", "removeNavigationButtons()");
addOnEvent("General", "show", "removeNavigationButtons()");
addOnEvent("Trip", "show", "removeNavigationButtons()");
addOnEvent("Shellfish_Aggregation", "show", "removeNavigationButtons()");
addOnEvent("Trip", "show", "addNavigationButtons(\"Trip\")");
addOnEvent("Shellfish_Aggregation", "show", "addNavigationButtons(\"Shellfish_Aggregation\")");

/******************************************************************************/
/*                                   SEARCH                                   */
/******************************************************************************/
addOnEvent("General/Search"               , "show"  , "search()");
addOnEvent("General/Search/Entity_List"   , "click" , "loadEntity();");
addOnEvent("General/Search/Search_Button" , "click" , "search()");
addOnEvent("General/Search/Search_Term"   , "click" , "clearSearch()");

addOnEvent("General/Search/Entity_Types"  , "click" , "search()");
entityTypes = new ArrayList();
entityTypes.add(new NameValuePair("{All}", ""));
entityTypes.add(new NameValuePair("{Trip}", "Trip"));
entityTypes.add(new NameValuePair("{Shellfish_Aggregation}", "Shellfish Aggregation"));
populateDropDown("General/Search/Entity_Types", entityTypes);

void clearSearch(){
  setFieldValue("General/Search/Search_Term","");
}

void search(){
  String refEntityList  = "General/Search/Entity_List";
  String refSearchTerm  = "General/Search/Search_Term";
  String refEntityTypes = "General/Search/Entity_Types";

  String type = getFieldValue(refEntityTypes);
  String term = getFieldValue(refSearchTerm);
  String searchQuery = "SELECT uuid, response "+
                       "  FROM latestNonDeletedArchEntFormattedIdentifiers  "+
                       " WHERE uuid in (SELECT uuid "+
                       "                  FROM latestNonDeletedArchEntIdentifiers "+
                       "                 WHERE measure LIKE {term}||'%'  "+
                       "                   AND ( aenttypename = {type} OR '' = {type} ) "+
                       "                )  "+
                       " ORDER BY response "+
                       " LIMIT ? "+
                       "OFFSET ? ";
  searchQuery = dbReplaceFirst(searchQuery, "{term}", term);
  searchQuery = dbReplaceFirst(searchQuery, "{type}", type);
  searchQuery = dbReplaceFirst(searchQuery, "{type}", type);

  populateMenu(refEntityList, MSG_LOADING);
  populateCursorList(refEntityList, searchQuery, 25);
  refreshTabgroupCSS("General");

  Log.d("Module", "Search query: " + searchQuery);
}

void loadTripFrom(String uuid) {
  String tabgroup = "Trip";
  setUuid(tabgroup, uuid);
  if (isNull(uuid)) return;

  FetchCallback cb = new FetchCallback() {
    onFetch(result) {
      populateEntityListsInTabGroup(tabgroup);
      executeOnEvent(tabgroup, "fetch");
    }
  };

  executeOnEvent(tabgroup, "prefetch");
  showTabGroup(tabgroup, uuid, cb);
}
void loadShellfishAggregationFrom(String uuid) {
  String tabgroup = "Shellfish_Aggregation";
  setUuid(tabgroup, uuid);
  if (isNull(uuid)) return;

  FetchCallback cb = new FetchCallback() {
    onFetch(result) {
      populateEntityListsInTabGroup(tabgroup);
      executeOnEvent(tabgroup, "fetch");
    }
  };

  executeOnEvent(tabgroup, "prefetch");
  showTabGroup(tabgroup, uuid, cb);
}

/******************************************************************************/
/*                          TAKE FROM GPS BUTTON(S)                           */
/******************************************************************************/
addOnEvent("Trip/Trip_data/Take_From_GPS_1", "click", "takePoint(\"Trip\")");

Map getTakeFromGpsMappings() {
  Map tabgroupToTabRef = new HashMap();
  tabgroupToTabRef.put("Trip", "Trip/Trip_data");
  return tabgroupToTabRef;
}

/* Takes the current point using gps. */
void takePoint(String tabgroup) {
  Map tabgroupToTabRef = getTakeFromGpsMappings();

  String archEntType = tabgroup.replaceAll("_", " ");
  String currentUuid = getUuid(tabgroup);
  if (isNull(currentUuid)){
    showToast("{Please_enter_data_first}");
    return;
  }

  boolean isInternalGPSOff = !isInternalGPSOn();
  boolean isExternalGPSOff = !isExternalGPSOn();
  Object  position = getGPSPosition();
  if (position == null || isInternalGPSOff && isExternalGPSOff) {
    showToast("{GPS_Not_Initialised}");
    return;
  }

  Object projPosition = getGPSPositionProjected();
  Double latitude     = position.getLatitude();
  Double longitude    = position.getLongitude();
  Double northing     = projPosition.getLatitude();
  Double easting      = projPosition.getLongitude();

  samplePoint = new Point(new MapPos(easting, northing), null, (PointStyle) null, null);
  ArrayList geolist = new ArrayList();
  geolist.add(samplePoint);

  String accuracy = "" + getGPSEstimatedAccuracy();
  setFieldValue(tabgroupToTabRef.get(tabgroup) + "/Accuracy", accuracy);

  saveArchEnt(currentUuid, archEntType, geolist, null, new SaveCallback() {
    onSave(uuid, newRecord) {
      print("[takePoint()] Added geometry: " + geolist);
      fillInGPS(tabgroup);
    }
  });
}

/* Sets the value of GPS views for the given tab ref. */
void fillInGPS(String tabgroup) {
  Map tabgroupToTabRef = getTakeFromGpsMappings();
  String currentUuid = getUuid(tabgroup);
  if (isNull(currentUuid)) {
    return;
  }

  String query = "SELECT x(transform(geospatialcolumn,                4326)) as longtiude, " +
                 "       y(transform(geospatialcolumn,                4326)) as latitude, " +
                 "       x(transform(geospatialcolumn, "+getModuleSrid()+")) as easting, " +
                 "       y(transform(geospatialcolumn, "+getModuleSrid()+")) as northing " +
                 "  FROM latestnondeletedarchent " +
                 " WHERE uuid = '" + currentUuid + "';";

  fetchOne(query, new FetchCallback() {
    onFetch(result) {
      print("[fillInGPS()] Fetched DB transformed geometry: " + result);
      setFieldValue(tabgroupToTabRef.get(tabgroup) + "/Longitude" , result.get(0));
      setFieldValue(tabgroupToTabRef.get(tabgroup) + "/Latitude"  , result.get(1));
      setFieldValue(tabgroupToTabRef.get(tabgroup) + "/Easting"   , result.get(2));
      setFieldValue(tabgroupToTabRef.get(tabgroup) + "/Northing"  , result.get(3));
    }
  });
}

void clearGpsInTabGroup(String tabgroup) {
  Map tabgroupToTabRef = getTakeFromGpsMappings();

  String tabRef = tabgroupToTabRef.get(tabgroup);
  if (isNull(tabRef)) return;

  clearGpsInTab(tabRef);
}

void clearGpsInTab(String tabRef) {
  setFieldValue(tabRef + "/Accuracy"  , "");
  setFieldValue(tabRef + "/Latitude"  , "");
  setFieldValue(tabRef + "/Longitude" , "");
  setFieldValue(tabRef + "/Easting"   , "");
  setFieldValue(tabRef + "/Northing"  , "");
}

/******************************************************************************/
/*               LOADING AND CREATION OF RECORDS FROM QR CODES                */
/******************************************************************************/
import java.util.regex.Pattern;
import java.util.regex.Matcher;


void bindQrScanning(String refButton, String refChild, boolean isChild) {
  String event = "click";

  String parentTabGroup;
  if (isChild) parentTabGroup = getTabGroupRef(refButton);
  else         parentTabGroup = null;

  String stmt = fun2str(
      "scanRecordFromQrCode",
      new Object[]{parentTabGroup, refChild}
  );

  addOnEvent(refButton, event, stmt);
}

void scanRecordFromQrCode(String parentTabGroup, String refChild) {
  String callback = fun2str(
      "loadOrCreateEntityFromScannedAttrib",
      new Object[]{parentTabGroup, refChild}
  );
  scanCode(callback);
}

void loadOrCreateEntityFromScannedAttrib(
    String parentTabGroup,
    String refChild
) {
  String code = getLastScanContents();

  String  uuidString  = "";
  Pattern uuidPattern = Pattern.compile("(\\d{19})");
  Matcher matcher     = uuidPattern.matcher(code);
  while (matcher.find())
    uuidString = matcher.group(1);

  if (isNull(uuidString)) {
    showWarning("{load_scanned_err_head}", "{load_scanned_err_body}");
    return;
  }

  loadEntityFrom(uuidString);
}



/******************************************************************************/
/*                       AUTONUMBERING HELPER FUNCTIONS                       */
/******************************************************************************/
Map AUTONUM_DEST_TO_SOURCE = new HashMap();


/*
 * If value of field specified by `ref` is null, sets the field to `defaultVal`,
 * otherwise increments its value.
 *
 * Returns the value the field was updated to.
 */
Integer incField(String ref, Integer defaultVal) {
  String val = getFieldValue(ref);

  if (isNull(val)) {
    setFieldValue(ref, defaultVal);
    return defaultVal;
  }

  Integer inc = Integer.parseInt(val) + 1;
  setFieldValue(ref, inc);
  insertIntoLocalSettings(ref, inc.toString());

  return inc;
}

/* Increments the field at `ref` or returns null if it does not contain a
 * number.
 */
Integer incField(String ref) {
  return incField(ref, 1);
}

for (String ref : getStartingIdRefs())
  persistOverSessions(ref, "1");

void incAutoNum(String destPath) {
  String sourcePath = AUTONUM_DEST_TO_SOURCE.get(destPath);
  String destVal    = getFieldValue(sourcePath);
  setFieldValue(destPath, destVal);
  incField(sourcePath);
}
/******************************************************************************/
/*                         POPULATION VIA <MARKDOWN>                          */
/******************************************************************************/
populateWebViewHtml("Login/User_login/Guide_User_Login", "<p>To login, please, select your name from the list of Users below, or if it’s your first time, register with the Sign up button.</p>\n");
populateWebViewHtml("Login/User_login/Signup_Guide_1", "<hr />\n<p>In order to sign up, please ensure:</p>\n<ol style=\"list-style-type: decimal\">\n<li>Your device is online</li>\n<li>You have choosen a strong password</li>\n</ol>\n<p>A strong password has at least 6 characters, 1 uppercase letter, 1 lowercase letter, 1 digit and 1 symbol. Examples of strong passwords:</p>\n<ul>\n<li>Bond@007</li>\n<li>Dig.123</li>\n</ul>\n");
populateWebViewHtml("Login/Manual/Manual", "<div class=\"figure\">\n<img src=\"files/data/guide/yourshore-logo.jpg\" />\n\n</div>\n<h1 id=\"yourshore-a-mobile-application-for-shoreline-exploration\"><strong>Your</strong>Shore: A mobile application for shoreline exploration</h1>\n<p><strong>Your</strong>Shore has been developed to allow community members and groups and other non-specialists to explore and record attributes about their local urban shorelines, covering broad aspects of habitat types, land use and species. With shellfish reefs in significant decline across Australia, a capacity to record the presence of any remnant shellfish reefs has also been included. <strong>Your</strong>Shore data will be validated and used by scientists to assess the health and habitat conditions of urban shorelines across a broad geographic area, as well as to pinpoint locations for possible shellfish restoration.</p>\n<p>The more users interact with <strong>Your</strong>Shore, the more useful it will be to scientists and to shoreline conservation and restoration. When using <strong>Your</strong>Shore, please remember to upload any relevant site images and add details about sites in the annotation boxes.</p>\n<p>Here at <strong>Your</strong>Shore we are keen to hear about how you use the app and how we can help.</p>\n<p>Find our details below.</p>\n<h2 id=\"field-instructions\"><strong>Field instructions</strong></h2>\n<ol style=\"list-style-type: decimal\">\n<li>Device requirements</li>\n</ol>\n<p><strong>Your</strong>Shore is currently available only for devices with Android 6+ operating systems. Registered users will be notified of any updates.</p>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>Downloading and installing <strong>Your</strong>Shore</li>\n</ol>\n<p><strong>Your</strong>Shore is free to download and install from Google Play at <a href=\"https://play.google.com/store\" class=\"uri\">https://play.google.com/store</a>. Search in ‘Apps’ for YourShore.</p>\n<ol start=\"3\" style=\"list-style-type: decimal\">\n<li>The <strong>Your</strong>Shore interface</li>\n</ol>\n<h4 id=\"status-bar\">Status Bar</h4>\n<p>The status bar can quickly show several things about your app. From left to right, the buttons denote the status of Autosave, Bluetooth, GPS signal, Tracklog and Sync operations. These operations are active when lit.</p>\n<div class=\"figure\">\n<img src=\"files/data/guide/status-bar.png\" />\n\n</div>\n<h4 id=\"navigation-pane\">Navigation Pane</h4>\n<p>If at any time you want to quickly navigate upwards in the hierarchy of the app, for example the login page, or if you need to create new, validate or delete a record, use the Navigation pane. Open it by swiping from the left edge of the device and dragging out the menu. You can also tap the three bar icon in the top left corner.</p>\n<div class=\"figure\">\n<img src=\"files/data/guide/navigation.png\" />\n\n</div>\n<p>More detailed help on navigating within FAIMS Mobile is available at:</p>\n<p><a href=\"https://faimsproject.atlassian.net/wiki/spaces/MobileUser/overview\" class=\"uri\">https://faimsproject.atlassian.net/wiki/spaces/MobileUser/overview</a></p>\n<ol start=\"4\" style=\"list-style-type: decimal\">\n<li>Logging in to <strong>Your</strong>Shore</li>\n</ol>\n<p><strong>Your</strong>Shore requires users to set a username and password. You can set this at the login page. Make sure that your device is online when setting the username and password so that it is recorded. During the data collection you work offline, but if you want to then sync your records, you need to go online. Use the Sync button to sync your settings across the <strong>Your</strong>Shore community when completed.</p>\n<ol start=\"5\" style=\"list-style-type: decimal\">\n<li>Starting a trip</li>\n</ol>\n<p>To start a trip in <strong>Your</strong>Shore, simply click on the ‘Start Trip’ bar that appears after the sign-on page. You will then be taken to the trip page, where tabs will show the three categories of records that can be entered: trip data, shoreline attributes and shellfish aggregations.</p>\n<p><img src=\"files/data/guide/general-tab-group-328-115.png\" /> <img src=\"files/data/guide/trip-328-115.png\" /></p>\n<p>For your trip to be recorded in the <strong>Your</strong>Shore database, you will need to enter the following details within the ‘TRIP DATA’ tab:</p>\n<ul>\n<li><p><strong>Location</strong>. Make sure your location is being recorded by checking the GPS signal indicator is lit in blue. If it’s grey, make sure to enable the Location on your device (usually via the Settings menu). To record the GPS coordinates, click on the ‘Take From GPS’ button in the Trip Tab and your current Latitude, Longitude, Northing, Easting and Accuracy will be automatically recorded.</p></li>\n<li><p><strong>Region and subregion</strong>. Use the dropdown menus within to select your region.</p></li>\n</ul>\n<p>As well as these details within the ‘SHORELINE ATTRIBUTES’ tab:</p>\n<ul>\n<li><p>Habitat types, dominant habitat – both natural and artificial</p></li>\n<li><p>Adjacent land use</p></li>\n<li><p>Presence/absence of wastewater outflows</p></li>\n<li><p>Shoreline slope</p></li>\n</ul>\n<ol start=\"6\" style=\"list-style-type: decimal\">\n<li>Navigating between the trip and individual observations, and Search</li>\n</ol>\n<p>Upon saving a trip (records are autosaved in 3-5 seconds after you finish touching the interface), you can tap the back button and will be brought into the General screen. If you are filling out an Aggregation, a tap on the Back button will take you back into your Trip. Continued tapping of the Back button will make you exit the module and require fresh login. Watch your fingers:)</p>\n<p>All saved records can be found in the Search tab which sits next to the General screen. Find your observation by using the filters provided. Search term accepts only the beginning of the alphanumeric string, e.g. you want to find a record ‘2018-04-17 Byron Bay Pacific Oyster’ it searches for ‘2018-04-17’, but not for ‘04-17’. Feel free to experiment with your search terms.</p>\n<ol start=\"7\" style=\"list-style-type: decimal\">\n<li>Checking for any missing data</li>\n</ol>\n<p>To check if you are missing any important data, click on the ‘Check for Missing Data’ button in the Trip / Shoreline Attributes Tab and a list of attributes with missing data will pop-up. You can also verify that no important information is missing by going/swiping to the Navigation pane and clicking the ‘Validate’ button.</p>\n<ol start=\"8\" style=\"list-style-type: decimal\">\n<li>Recording parameters</li>\n</ol>\n<h4 id=\"shoreline-attributes\">Shoreline attributes</h4>\n<p><strong>Your</strong>Shore first asks you to look around at the shoreline and observe and record its basic features and characteristics. Are you on a beach or a mudflat area? Are you near a playground or sport park, in bushland or near a major road? Are there mainly houses and roads nearby, or are you in an industrial area? What types of animals can you see using the shoreline? These records will help scientists to determine what the habitat <em>value</em> of the shoreline is to resident species.</p>\n<p>Be sure to only record animals <em>directly</em> interacting with the shoreline – e.g. walking on the beach, digging in the sand, diving for fish etc. Do not record domesticated animals such as dogs.</p>\n<p>Fill out each field as best you can, adding images or annotated notes where applicable.</p>\n<h4 id=\"shellfish-aggregations\">Shellfish aggregations</h4>\n<p>The presence of clusters or aggregations or shellfish along your shoreline is important information for restoration scientists. Please carefully record as much data as you can about these aggregations. The following guidelines will help you record the details.</p>\n<h5 id=\"shellfish-type-and-species\">Shellfish type and species</h5>\n<p>Generally, attached shellfish will be one of two major groups – oysters or mussels.</p>\n<ul>\n<li><p>Mussels are generally smooth-shelled with rounded edges to the shells and are attached by <em>byssal</em>threads to the substrate.</p></li>\n<li><p>Oysters are most often irregularly shaped, with ‘ruffled’ or irregular shell edges, have layers of shell that are often rough or irregular, and are cemented to the substrate.</p></li>\n</ul>\n<p>Record whether you have a mussel or oyster; refer to the photo gallery if unsure.</p>\n<p>Shellfish species can be hard to differentiate in the field but any information is useful! Please use the photo gallery to select the species that most closely resembles those at your site.</p>\n<p>Scientists can use your recorded data and photo, along with the location, to make a best estimate of the likely species, and follow up with field validation if required.</p>\n<h5 id=\"primary-and-surrounding-substrate\">Primary and surrounding substrate</h5>\n<p>‘Substrate’ refers to the surface on which the shellfish is sitting.</p>\n<ul>\n<li><p>We use the term ‘primary substrate’ to denote the surface that the shellfish is <em>directly</em> attached to. This will most likely be a rock, pier piling or other hard surface e.g. sea wall.</p></li>\n<li><p>The ‘secondary substrate’ is the surface surrounding the aggregation. This can give us an idea of how <em>available</em>the primary substrate is to the incoming shellfish larvae.</p></li>\n</ul>\n<p>It can be tricky to determine the surrounding substrate, particularly if the primary substrate is extensive. Upload a photo to assist with our validation.</p>\n<h5 id=\"shellfish-status\">Shellfish status</h5>\n<p>It is important to determine if the shoreline has conditions to support living shellfish. Live shellfish that are out of the water will generally be firmly closed with both shells intact. Gaping shells or incomplete shells are indicative of dead shellfish.</p>\n<table style=\"width:11%;\">\n<colgroup>\n<col width=\"5%\" />\n<col width=\"5%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th><img src=\"files/data/guide/oyster.jpg\" /></th>\n<th>The photo at left shows a live oyster (left) next to a dead, gaping oyster (right).</th>\n</tr>\n</thead>\n<tbody>\n</tbody>\n</table>\n<p>At a close distance, observe the shellfish in the aggregation and record their status – do you think most are dead or alive?</p>\n<p>If you are unable to observe the shellfish aggregation at a close enough distance, leave this field blank.</p>\n<h5 id=\"distance-to-water\">Distance to water</h5>\n<p>Observe how far the shellfish aggregation is from a permanent marine or brackish water body. Estimate in metres.</p>\n<h5 id=\"size-of-aggregation\">Size of aggregation</h5>\n<p>Use the pictures to help you estimate the numbers of shellfish within an aggregation.</p>\n<p>Aggregations can often cover extensive areas horizontally, e.g. along the tidal mark. Make a note of the approximate shape of the aggregation in the annotations for this field and upload a photo.</p>\n<h5 id=\"density-of-aggregation\">Density of aggregation</h5>\n<p>Shellfish that are closer together will have a greater chance of reproductive success, so it is important that we record density of aggregations.</p>\n<p>To do this, identify an area of the aggregation where the shellfish are most closely packed together. Place your device close to the aggregation and estimate how many individuals fit into the area of your device. Make a note of the type of device in the annotation box. If you cannot closely observe the aggregation, please estimate density and annotate the record with your observations.</p>\n<p>In both cases, upload a photo for validation, placing an object such as a coin or rule next to the aggregation for scale.</p>\n<h5 id=\"shellfish-photos\">Shellfish photos</h5>\n<p>Remember to take photos of the shellfish aggregation(s) that you have seen on your trip, as these will help scientists and other users to identify the species and to validate the parameters that you have recorded.</p>\n<p>There is no limit to the number of images that can be uploaded to this section of the app, although bear in mind that uploading these images will take time once you are in wifi range.</p>\n<p>Thank you for using <strong>Your</strong>Shore – your participation is much appreciated. Your feedback is very important to us, so please get in touch! 😊</p>\n<h2 id=\"additional-help-and-resources\"><strong>Additional help and resources</strong></h2>\n<p>For more information on the <strong>Your</strong>Shore and FAIMS Mobile platform, please refer to the FAIMS Mobile User guide: <a href=\"https://faimsproject.atlassian.net/wiki/spaces/MobileUser/overview\" class=\"uri\">https://faimsproject.atlassian.net/wiki/spaces/MobileUser/overview</a></p>\n<p>For questions on field parameters, protocols and <strong>Your</strong>Shore data collection:</p>\n<ul>\n<li><strong>Dr Elisa Bone</strong>, <strong>Your</strong>Shore administrator and scientist, Ashore Consulting: <a href=\"mailto:ashoreconsulting@gmail.com\">ashoreconsulting@gmail.com</a></li>\n</ul>\n<p>For questions on software development and technical issues:</p>\n<ul>\n<li><p><strong>Dr Adela Sobotkova</strong>, FAIMS Project deputy director: <a href=\"mailto:adela@fedarch.org\">adela@fedarch.org</a></p></li>\n<li><p><strong>Dr Petra Janouchova</strong>, FAIMS Project manager: <a href=\"mailto:petra@fedarch.org\">petra@fedarch.org</a></p></li>\n</ul>\n<p>For more information on shellfish species, characteristics, and restoration status in Australia:</p>\n<ul>\n<li>Shellfish Reef Restoration Network: <a href=\"https://www.shellfishrestoration.org.au/\" class=\"uri\">https://www.shellfishrestoration.org.au/</a></li>\n</ul>\n<p><strong>Your</strong>Shore has grown from and been informed by other projects on urban shoreline habitats, including:</p>\n<ul>\n<li><p>Billion Oyster Project, New York: <a href=\"http://www.billionoysterproject.org\" class=\"uri\">http://www.billionoysterproject.org</a></p></li>\n<li><p>New York-New Jersey Harbour Estuary Program: <a href=\"http://www.harborestuary.org/aboutestuary-habitats-shorelines.htm\" class=\"uri\">http://www.harborestuary.org/aboutestuary-habitats-shorelines.htm</a></p></li>\n<li><p>World Harbour Project: <a href=\"http://www.worldharbourproject.org/\" class=\"uri\">http://www.worldharbourproject.org/</a></p></li>\n</ul>\n<p><img src=\"files/data/guide/faims-logo-95-95.png\" /> <img src=\"files/data/guide/ashore-147-95.png\" /></p>\n");
populateWebViewHtml("General/Manual/Manual", "<div class=\"figure\">\n<img src=\"files/data/guide/yourshore-logo.jpg\" />\n\n</div>\n<h1 id=\"yourshore-a-mobile-application-for-shoreline-exploration\"><strong>Your</strong>Shore: A mobile application for shoreline exploration</h1>\n<p><strong>Your</strong>Shore has been developed to allow community members and groups and other non-specialists to explore and record attributes about their local urban shorelines, covering broad aspects of habitat types, land use and species. With shellfish reefs in significant decline across Australia, a capacity to record the presence of any remnant shellfish reefs has also been included. <strong>Your</strong>Shore data will be validated and used by scientists to assess the health and habitat conditions of urban shorelines across a broad geographic area, as well as to pinpoint locations for possible shellfish restoration.</p>\n<p>The more users interact with <strong>Your</strong>Shore, the more useful it will be to scientists and to shoreline conservation and restoration. When using <strong>Your</strong>Shore, please remember to upload any relevant site images and add details about sites in the annotation boxes.</p>\n<p>Here at <strong>Your</strong>Shore we are keen to hear about how you use the app and how we can help.</p>\n<p>Find our details below.</p>\n<h2 id=\"field-instructions\"><strong>Field instructions</strong></h2>\n<ol style=\"list-style-type: decimal\">\n<li>Device requirements</li>\n</ol>\n<p><strong>Your</strong>Shore is currently available only for devices with Android 6+ operating systems. Registered users will be notified of any updates.</p>\n<ol start=\"2\" style=\"list-style-type: decimal\">\n<li>Downloading and installing <strong>Your</strong>Shore</li>\n</ol>\n<p><strong>Your</strong>Shore is free to download and install from Google Play at <a href=\"https://play.google.com/store\" class=\"uri\">https://play.google.com/store</a>. Search in ‘Apps’ for YourShore.</p>\n<ol start=\"3\" style=\"list-style-type: decimal\">\n<li>The <strong>Your</strong>Shore interface</li>\n</ol>\n<h4 id=\"status-bar\">Status Bar</h4>\n<p>The status bar can quickly show several things about your app. From left to right, the buttons denote the status of Autosave, Bluetooth, GPS signal, Tracklog and Sync operations. These operations are active when lit.</p>\n<div class=\"figure\">\n<img src=\"files/data/guide/status-bar.png\" />\n\n</div>\n<h4 id=\"navigation-pane\">Navigation Pane</h4>\n<p>If at any time you want to quickly navigate upwards in the hierarchy of the app, for example the login page, or if you need to create new, validate or delete a record, use the Navigation pane. Open it by swiping from the left edge of the device and dragging out the menu. You can also tap the three bar icon in the top left corner.</p>\n<div class=\"figure\">\n<img src=\"files/data/guide/navigation.png\" />\n\n</div>\n<p>More detailed help on navigating within FAIMS Mobile is available at:</p>\n<p><a href=\"https://faimsproject.atlassian.net/wiki/spaces/MobileUser/overview\" class=\"uri\">https://faimsproject.atlassian.net/wiki/spaces/MobileUser/overview</a></p>\n<ol start=\"4\" style=\"list-style-type: decimal\">\n<li>Logging in to <strong>Your</strong>Shore</li>\n</ol>\n<p><strong>Your</strong>Shore requires users to set a username and password. You can set this at the login page. Make sure that your device is online when setting the username and password so that it is recorded. During the data collection you work offline, but if you want to then sync your records, you need to go online. Use the Sync button to sync your settings across the <strong>Your</strong>Shore community when completed.</p>\n<ol start=\"5\" style=\"list-style-type: decimal\">\n<li>Starting a trip</li>\n</ol>\n<p>To start a trip in <strong>Your</strong>Shore, simply click on the ‘Start Trip’ bar that appears after the sign-on page. You will then be taken to the trip page, where tabs will show the three categories of records that can be entered: trip data, shoreline attributes and shellfish aggregations.</p>\n<p><img src=\"files/data/guide/general-tab-group-328-115.png\" /> <img src=\"files/data/guide/trip-328-115.png\" /></p>\n<p>For your trip to be recorded in the <strong>Your</strong>Shore database, you will need to enter the following details within the ‘TRIP DATA’ tab:</p>\n<ul>\n<li><p><strong>Location</strong>. Make sure your location is being recorded by checking the GPS signal indicator is lit in blue. If it’s grey, make sure to enable the Location on your device (usually via the Settings menu). To record the GPS coordinates, click on the ‘Take From GPS’ button in the Trip Tab and your current Latitude, Longitude, Northing, Easting and Accuracy will be automatically recorded.</p></li>\n<li><p><strong>Region and subregion</strong>. Use the dropdown menus within to select your region.</p></li>\n</ul>\n<p>As well as these details within the ‘SHORELINE ATTRIBUTES’ tab:</p>\n<ul>\n<li><p>Habitat types, dominant habitat – both natural and artificial</p></li>\n<li><p>Adjacent land use</p></li>\n<li><p>Presence/absence of wastewater outflows</p></li>\n<li><p>Shoreline slope</p></li>\n</ul>\n<ol start=\"6\" style=\"list-style-type: decimal\">\n<li>Navigating between the trip and individual observations, and Search</li>\n</ol>\n<p>Upon saving a trip (records are autosaved in 3-5 seconds after you finish touching the interface), you can tap the back button and will be brought into the General screen. If you are filling out an Aggregation, a tap on the Back button will take you back into your Trip. Continued tapping of the Back button will make you exit the module and require fresh login. Watch your fingers:)</p>\n<p>All saved records can be found in the Search tab which sits next to the General screen. Find your observation by using the filters provided. Search term accepts only the beginning of the alphanumeric string, e.g. you want to find a record ‘2018-04-17 Byron Bay Pacific Oyster’ it searches for ‘2018-04-17’, but not for ‘04-17’. Feel free to experiment with your search terms.</p>\n<ol start=\"7\" style=\"list-style-type: decimal\">\n<li>Checking for any missing data</li>\n</ol>\n<p>To check if you are missing any important data, click on the ‘Check for Missing Data’ button in the Trip / Shoreline Attributes Tab and a list of attributes with missing data will pop-up. You can also verify that no important information is missing by going/swiping to the Navigation pane and clicking the ‘Validate’ button.</p>\n<ol start=\"8\" style=\"list-style-type: decimal\">\n<li>Recording parameters</li>\n</ol>\n<h4 id=\"shoreline-attributes\">Shoreline attributes</h4>\n<p><strong>Your</strong>Shore first asks you to look around at the shoreline and observe and record its basic features and characteristics. Are you on a beach or a mudflat area? Are you near a playground or sport park, in bushland or near a major road? Are there mainly houses and roads nearby, or are you in an industrial area? What types of animals can you see using the shoreline? These records will help scientists to determine what the habitat <em>value</em> of the shoreline is to resident species.</p>\n<p>Be sure to only record animals <em>directly</em> interacting with the shoreline – e.g. walking on the beach, digging in the sand, diving for fish etc. Do not record domesticated animals such as dogs.</p>\n<p>Fill out each field as best you can, adding images or annotated notes where applicable.</p>\n<h4 id=\"shellfish-aggregations\">Shellfish aggregations</h4>\n<p>The presence of clusters or aggregations or shellfish along your shoreline is important information for restoration scientists. Please carefully record as much data as you can about these aggregations. The following guidelines will help you record the details.</p>\n<h5 id=\"shellfish-type-and-species\">Shellfish type and species</h5>\n<p>Generally, attached shellfish will be one of two major groups – oysters or mussels.</p>\n<ul>\n<li><p>Mussels are generally smooth-shelled with rounded edges to the shells and are attached by <em>byssal</em>threads to the substrate.</p></li>\n<li><p>Oysters are most often irregularly shaped, with ‘ruffled’ or irregular shell edges, have layers of shell that are often rough or irregular, and are cemented to the substrate.</p></li>\n</ul>\n<p>Record whether you have a mussel or oyster; refer to the photo gallery if unsure.</p>\n<p>Shellfish species can be hard to differentiate in the field but any information is useful! Please use the photo gallery to select the species that most closely resembles those at your site.</p>\n<p>Scientists can use your recorded data and photo, along with the location, to make a best estimate of the likely species, and follow up with field validation if required.</p>\n<h5 id=\"primary-and-surrounding-substrate\">Primary and surrounding substrate</h5>\n<p>‘Substrate’ refers to the surface on which the shellfish is sitting.</p>\n<ul>\n<li><p>We use the term ‘primary substrate’ to denote the surface that the shellfish is <em>directly</em> attached to. This will most likely be a rock, pier piling or other hard surface e.g. sea wall.</p></li>\n<li><p>The ‘secondary substrate’ is the surface surrounding the aggregation. This can give us an idea of how <em>available</em>the primary substrate is to the incoming shellfish larvae.</p></li>\n</ul>\n<p>It can be tricky to determine the surrounding substrate, particularly if the primary substrate is extensive. Upload a photo to assist with our validation.</p>\n<h5 id=\"shellfish-status\">Shellfish status</h5>\n<p>It is important to determine if the shoreline has conditions to support living shellfish. Live shellfish that are out of the water will generally be firmly closed with both shells intact. Gaping shells or incomplete shells are indicative of dead shellfish.</p>\n<table style=\"width:11%;\">\n<colgroup>\n<col width=\"5%\" />\n<col width=\"5%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th><img src=\"files/data/guide/oyster.jpg\" /></th>\n<th>The photo at left shows a live oyster (left) next to a dead, gaping oyster (right).</th>\n</tr>\n</thead>\n<tbody>\n</tbody>\n</table>\n<p>At a close distance, observe the shellfish in the aggregation and record their status – do you think most are dead or alive?</p>\n<p>If you are unable to observe the shellfish aggregation at a close enough distance, leave this field blank.</p>\n<h5 id=\"distance-to-water\">Distance to water</h5>\n<p>Observe how far the shellfish aggregation is from a permanent marine or brackish water body. Estimate in metres.</p>\n<h5 id=\"size-of-aggregation\">Size of aggregation</h5>\n<p>Use the pictures to help you estimate the numbers of shellfish within an aggregation.</p>\n<p>Aggregations can often cover extensive areas horizontally, e.g. along the tidal mark. Make a note of the approximate shape of the aggregation in the annotations for this field and upload a photo.</p>\n<h5 id=\"density-of-aggregation\">Density of aggregation</h5>\n<p>Shellfish that are closer together will have a greater chance of reproductive success, so it is important that we record density of aggregations.</p>\n<p>To do this, identify an area of the aggregation where the shellfish are most closely packed together. Place your device close to the aggregation and estimate how many individuals fit into the area of your device. Make a note of the type of device in the annotation box. If you cannot closely observe the aggregation, please estimate density and annotate the record with your observations.</p>\n<p>In both cases, upload a photo for validation, placing an object such as a coin or rule next to the aggregation for scale.</p>\n<h5 id=\"shellfish-photos\">Shellfish photos</h5>\n<p>Remember to take photos of the shellfish aggregation(s) that you have seen on your trip, as these will help scientists and other users to identify the species and to validate the parameters that you have recorded.</p>\n<p>There is no limit to the number of images that can be uploaded to this section of the app, although bear in mind that uploading these images will take time once you are in wifi range.</p>\n<p>Thank you for using <strong>Your</strong>Shore – your participation is much appreciated. Your feedback is very important to us, so please get in touch! 😊</p>\n<h2 id=\"additional-help-and-resources\"><strong>Additional help and resources</strong></h2>\n<p>For more information on the <strong>Your</strong>Shore and FAIMS Mobile platform, please refer to the FAIMS Mobile User guide: <a href=\"https://faimsproject.atlassian.net/wiki/spaces/MobileUser/overview\" class=\"uri\">https://faimsproject.atlassian.net/wiki/spaces/MobileUser/overview</a></p>\n<p>For questions on field parameters, protocols and <strong>Your</strong>Shore data collection:</p>\n<ul>\n<li><strong>Dr Elisa Bone</strong>, <strong>Your</strong>Shore administrator and scientist, Ashore Consulting: <a href=\"mailto:ashoreconsulting@gmail.com\">ashoreconsulting@gmail.com</a></li>\n</ul>\n<p>For questions on software development and technical issues:</p>\n<ul>\n<li><p><strong>Dr Adela Sobotkova</strong>, FAIMS Project deputy director: <a href=\"mailto:adela@fedarch.org\">adela@fedarch.org</a></p></li>\n<li><p><strong>Dr Petra Janouchova</strong>, FAIMS Project manager: <a href=\"mailto:petra@fedarch.org\">petra@fedarch.org</a></p></li>\n</ul>\n<p>For more information on shellfish species, characteristics, and restoration status in Australia:</p>\n<ul>\n<li>Shellfish Reef Restoration Network: <a href=\"https://www.shellfishrestoration.org.au/\" class=\"uri\">https://www.shellfishrestoration.org.au/</a></li>\n</ul>\n<p><strong>Your</strong>Shore has grown from and been informed by other projects on urban shoreline habitats, including:</p>\n<ul>\n<li><p>Billion Oyster Project, New York: <a href=\"http://www.billionoysterproject.org\" class=\"uri\">http://www.billionoysterproject.org</a></p></li>\n<li><p>New York-New Jersey Harbour Estuary Program: <a href=\"http://www.harborestuary.org/aboutestuary-habitats-shorelines.htm\" class=\"uri\">http://www.harborestuary.org/aboutestuary-habitats-shorelines.htm</a></p></li>\n<li><p>World Harbour Project: <a href=\"http://www.worldharbourproject.org/\" class=\"uri\">http://www.worldharbourproject.org/</a></p></li>\n</ul>\n<p><img src=\"files/data/guide/faims-logo-95-95.png\" /> <img src=\"files/data/guide/ashore-147-95.png\" /></p>\n");
populateWebViewHtml("Trip/Trip_data/GPS_Guide", "<p>Pick a location at which to observe the shoreline</p>\n");
populateWebViewHtml("Trip/Shellfish_Aggregation/Add_Shellfish_Aggregation_Guide", "<p>Add a new kind of shellfish aggregation to the current trip/shoreline</p>\n");
populateWebViewHtml("Trip/Shellfish_Aggregation/HR_Guide", "<br />\n\n");
populateWebViewHtml("Trip/Shellfish_Aggregation/Existing_Aggregations_Guide", "<p>The list below will show the shellfish aggregations documented previously at this location</p>\n");

/******************************************************************************/
/*                POPULATION OF ENTITY AND CHILD ENTITY LISTS                 */
/******************************************************************************/
/*
 * `ref`       the reference of the GUI element to be populated.
 * `parentUuid` the parent in the relationship denoted by `relType`.
 * `entType`    the type of the entities the menu will be populated with.
 * `relType`    the name of the relationship the children are to be in with the
 *              entity denoted by `parentUuid`.
 */
void populateMenuWithEntities (
  String ref,
  String parentUuid,
  String entType,
  String relType
) {
  String viewType = getType(ref);

  String limit;
  switch (viewType) {
    case "dropdown": limit = "";                   break;
    case "list":     limit = " LIMIT ? OFFSET ? "; break;
  }

  String getChildEntitiesQ = "" +
    "SELECT childuuid, response " +
    "  FROM (select childuuid, createdat" +
    "          from (select childuuid, createdat, relationshipid" +
    "                    from parentchild" +
    "                   where parentuuid = '" + parentUuid + "' " +
    "                   and (childaenttypename = '"+entType+"')" +
    "                   order by createdat           " +
    "                   )" +
    "          JOIN (SELECT relationshipid   " +
    "                  FROM latestnondeletedrelationship JOIN relntype USING (relntypeid)  " +
    "                 WHERE relntypename = '"+relType+"') USING (relationshipid)" +
    "          order by createdat desc" +
    limit +
    "        )  " +
    "  JOIN latestNonDeletedArchEntFormattedIdentifiers ON (childuuid = uuid)   " +
    "  order by createdat desc";

  String getEntitiesQ = "" +
    "SELECT uuid, response "+
    "  FROM latestNonDeletedArchEntFormattedIdentifiers  "+
    " WHERE uuid in (SELECT uuid "+
    "                  FROM latestNonDeletedArchEntIdentifiers "+
    "                 WHERE aenttypename = '"+entType+"' OR '"+entType+"' = '' " +
    "               )  "+
    " ORDER BY response " +
    limit;

  FetchCallback cbPopulateDropDown = new FetchCallback() {
    onFetch(result) {
      populateDropDown(ref, result, true);
    }
  };

  String q;
  if (relType.equals("")) q = getEntitiesQ;
  else                    q = getChildEntitiesQ;

  switch (viewType) {
    case "dropdown": fetchAll(q, cbPopulateDropDown); break;
    case "list":     populateCursorList(ref, q, 25); break;
  }
}

void populateEntityListsInTabGroup(String tabGroup) {
  if (isNull(tabGroup)) {
    return;
  }

  for (m : ENTITY_MENUS) {
    String ref          = m[0];
    String menuTabGroup = getTabGroupRef(ref);
    String functionCall = getEntityMenuPopulationFunction(m);

    if (menuTabGroup.equals(tabGroup))
      execute(functionCall);
  }
}

/* Populates each list containing records whose archent type is the same as that
 * of `tabGroup`.
 */
void populateEntityListsOfArchEnt(String tabGroup) {
  if (isNull(tabGroup)) {
    return;
  }

  String archEntTypeToPopulate = getArchEntType(tabGroup);

  for (m : ENTITY_MENUS) {
    String archEntType  = m[2];
    String functionCall = getEntityMenuPopulationFunction(m);

    if (archEntType.equals(archEntTypeToPopulate))
      execute(functionCall);
  }
}

String getEntityMenuPopulationFunction(String[] menuDescriptor) {
  String ref            = menuDescriptor[0];
  String parentUuidCall = menuDescriptor[1];
  String entType        = menuDescriptor[2];
  String relType        = menuDescriptor[3];

  String functionCall = "";
  functionCall += "populateMenuWithEntities(";
  functionCall += "\"" + ref            + "\"";
  functionCall += ", ";
  functionCall +=        parentUuidCall       ;
  functionCall += ", ";
  functionCall += "\"" + entType        + "\"";
  functionCall += ", ";
  functionCall += "\"" + relType        + "\"";
  functionCall += ")";

  return functionCall;
}

ENTITY_MENUS = new ArrayList();
ENTITY_MENUS.add(new String[] {
    "Trip/Shellfish_Aggregation/Existing_Aggregations",
    "getUuid(\"Trip\")",
    "Shellfish Aggregation",
    "Trip - Shellfish Aggregation"
});
for (m : ENTITY_MENUS) {
  String functionCall = getEntityMenuPopulationFunction(m);
  execute(functionCall);
}
for (m : ENTITY_MENUS) {
  String menuRef = m[0];

  String ref = getTabRef(menuRef);
  String evt = "show";
  String cmd = "clearField(\"{menuRef}\")";
  cmd = replaceFirst(cmd, "{menuRef}", menuRef);

  addOnEvent(ref, evt, cmd);
}

addOnEvent("Trip/Shellfish_Aggregation/Existing_Aggregations", "click", "loadEntity()");
/******************************************************************************/
/*                             HANDWRITTEN LOGIC                              */
/******************************************************************************/

/****************************** DATE/TIME POPULATION *******************************/
final String REF_AGGREGATE_DATE = "Shellfish_Aggregation/Shellfish_Type/Date";
final String REF_AGGREGATE_TIME = "Shellfish_Aggregation/Shellfish_Type/Time";

void setDateTime(String ref, String fmt) {
  date    = new Date();
  dateFmt = new java.text.SimpleDateFormat(fmt);
  dateStr = dateFmt.format(date);
  if(dateStr.endsWith(".")){
    dateStr = dateStr.substring(0, dateStr.length()-1);
  }
  setFieldValue(ref, dateStr);
}

addOnEvent("Trip", "create", "setDateTime(\"Trip/Trip_data/Date\",\"yyyy-MM-dd\")");
addOnEvent("Trip", "create", "setDateTime(\"Trip/Trip_data/Time\",\"HH:mm:ss\")");


addOnEvent("Shellfish_Aggregation", "create", "setDateTime(REF_AGGREGATE_DATE,\"yyyy-MM-dd\")");
addOnEvent("Shellfish_Aggregation", "create", "setDateTime(REF_AGGREGATE_TIME,\"HH:mm:ss\")");
/****************************** DROPDOWN FOR SEARCH *******************************/
addOnEvent("General/Search/Select_Subregion", "click", "search()");
addOnEvent("General/Search/Select_User", "click", "search()");
void setDropdownByVocab(String vocabName, String ref) {
  List regionList = new ArrayList();

  fetchAll("select vocabname from vocabulary left join attributekey using (attributeid) where attributename = '" + vocabName + "';", new FetchCallback() {
    onFetch(result) {
      if (isNull(result))
        result = new ArrayList();
      Set vocabSet = new LinkedHashSet();
      //vocabSet.add("All");
      for(item : result){
        String s = guessArch16nValFromKey(item.get(0));
        vocabSet.add(s);
      }
      regionList.addAll(vocabSet);
      populateDropDown(ref,regionList,true);
    }
  });

}
addOnEvent("General/Search", "show", "populateHierarchicalDropDown(\"General/Search/Select_Subregion\", \"Trip Subregion\", true)");
//addOnEvent("General/Search", "show", "populateHierarchicalDropDown(\"General/Search/Select_Region\",\"Region\", true)");
//addOnEvent("General/Search", "show", "setDropdownByVocab(\"State\",\"General/Search/Select_State\")");
addOnEvent("General/Search", "show", "populateSelectUser()");
void populateSelectUser(){
  String refSearchUsers = "General/Search/Select_User";
  String getNonDeletedUsersQuery = "SELECT userid, fname || ' ' || lname "+
                                   "  FROM user "+
                                   " WHERE userdeleted is null "+
                                   " UNION " +
                                   "SELECT -1, '{All}'";

  fetchAll(getNonDeletedUsersQuery, new FetchCallback() {
    onFetch(result) {
      populateDropDown(refSearchUsers, result, false);
    }
  });
}
/****************************** SEARCH EXTENSION ******************************/
/* Implements an extension to the search page which allows users to           */
/* constrain their searches by existing column                                */
/******************************************************************************/
void search(){
  String tabgroup = "General";
  String refEntityList  = tabgroup + "/Search/Entity_List";
  String refSearchTerm  = tabgroup + "/Search/Search_Term";
  String refEntityTypes = tabgroup + "/Search/Entity_Types";
  String refSelectUser = tabgroup + "/Search/Select_User";
  String refSubregion = tabgroup + "/Search/Select_Subregion";

  String type = getFieldValue(refEntityTypes);
  String term = getFieldValue(refSearchTerm);

  String user = getFieldValue(refSelectUser);
  String subregion = getFieldValue(refSubregion);



  String searchQuery = "select uuid, response " +
                       " from latestNonDeletedArchEntFormattedIdentifiers " +
                       "where (aenttypename LIKE '{type}' OR '' = '{type}' ) " +
                       " AND (substr(uuid,2,5) = ltrim('0000' || {user}) " +
                       " OR {user} = -1) " +
                       " and (uuid in (select uuid " +
                       "                from latestnondeletedaentvalue " +
                       "                where vocabid = '{subregionId}') " +
                       "        OR '{subregionId}' = 'null') " +
                       " and   uuid in (SELECT uuid "+
                       "                  FROM latestNonDeletedArchEntIdentifiers "+
                       "                 WHERE measure LIKE '{term}'||'%'  "+
                       "                )  "+
                       " ORDER BY response " +
                       " LIMIT ? " +
                       "OFFSET ? ";

   searchQuery = replaceFirst(searchQuery, "{term}", term);
   searchQuery = replaceFirst(searchQuery, "{type}", type);
   searchQuery = replaceFirst(searchQuery, "{type}", type);
   searchQuery = replaceFirst(searchQuery, "{user}", user);
   searchQuery = replaceFirst(searchQuery, "{user}", user);
   searchQuery = replaceFirst(searchQuery, "{subregionId}", subregion);
   searchQuery = replaceFirst(searchQuery, "{subregionId}", subregion);


  populateCursorList(refEntityList, searchQuery, 25);
  refreshTabgroupCSS("General");

  Log.d("Module", "Search query: " + searchQuery);
}
/*************************** CHECK FOR MISSING DATA ***************************/
addOnEvent(
    "Trip/Shoreline_attributes/Check_for_Missing_Data",
    "click",
    "validateTrip()"
);
  

/******************************************************************************/
/*                                    INIT                                    */
/*                                                                            */
/* Stuff which needs to be done last.                                         */
/******************************************************************************/
bindOnEvents();
decAndExecIfModuleLoaded();
